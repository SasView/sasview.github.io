<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Optimizer Selection &mdash; SasView 4.1.2 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '4.1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="top" title="SasView 4.1.2 documentation" href="../../../../index.html" />
    <link rel="up" title="Fitting Documentation" href="fitting.html" />
    <link rel="next" title="SANS to SESANS conversion" href="../../../sans_to_sesans.html" />
    <link rel="prev" title="Polarisation/Magnetic Scattering" href="mag_help.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../sans_to_sesans.html" title="SANS to SESANS conversion"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mag_help.html" title="Polarisation/Magnetic Scattering"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SasView 4.1.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../user.html" >SasView User Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../../../analysis.html" >Fitting &amp; Other Analyses</a> &raquo;</li>
          <li class="nav-item nav-item-3"><a href="fitting.html" accesskey="U">Fitting Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="optimizer-selection">
<span id="optimizer-guide"></span><h1>Optimizer Selection</h1>
<p>Bumps has a number of different optimizers available, each with its own
control parameters:</p>
<ul class="simple">
<li><a class="reference internal" href="#fit-lm"><span class="std std-ref">Levenberg-Marquardt</span></a></li>
<li><a class="reference internal" href="#fit-amoeba"><span class="std std-ref">Nelder-Mead Simplex</span></a></li>
<li><a class="reference internal" href="#fit-dream"><span class="std std-ref">DREAM</span></a></li>
<li><a class="reference internal" href="#fit-de"><span class="std std-ref">Differential Evolution</span></a></li>
<li><a class="reference internal" href="#fit-newton"><span class="std std-ref">Quasi-Newton BFGS</span></a></li>
<li><a class="reference internal" href="#fit-rl"><span class="std std-ref">Random Lines</span></a> [experimental]</li>
<li><a class="reference internal" href="#fit-ps"><span class="std std-ref">Particle Swarm</span></a> [experimental]</li>
<li><a class="reference internal" href="#fit-pt"><span class="std std-ref">Parallel Tempering</span></a> [experimental]</li>
</ul>
<p>In general there is a trade-off between convergence
rate and robustness, with the fastest algorithms most likely to find a
local minimum rather than a global minimum.   The gradient descent algorithms
(<a class="reference internal" href="#fit-lm"><span class="std std-ref">Levenberg-Marquardt</span></a>, <a class="reference internal" href="#fit-newton"><span class="std std-ref">Quasi-Newton BFGS</span></a>) tend to be fast but they will find local
minima only, while the population algorithms (<a class="reference internal" href="#fit-dream"><span class="std std-ref">DREAM</span></a>, <a class="reference internal" href="#fit-de"><span class="std std-ref">Differential Evolution</span></a>)
are more robust and likely slower.   <a class="reference internal" href="#fit-amoeba"><span class="std std-ref">Nelder-Mead Simplex</span></a> is somewhere between,
with a small population keeping the search local but more robust than the
gradient descent algorithms.</p>
<p>Each algorithm has its own set of control parameters for adjusting the
search process and the stopping conditions.  The same option may mean
slightly different things to different optimizers.  The bumps package
provides a dialog box for selecting the optimizer and its options
when running the fit wx application.  This only includes the common options
for the most useful optimizers.  For full control, the fit will need to
be run from the command line interface or through a python script.</p>
<p>For parameter uncertainty, most algorithms use the covariance matrix at
the optimum to estimate an uncertainty ellipse.  This is okay for a
preliminary analysis, but only works reliably for weakly correlated parameters.
For full uncertainty analysis, <a class="reference internal" href="#fit-dream"><span class="std std-ref">DREAM</span></a> uses a random walk to explore
the parameter space near the minimum, showing pair-wise correlations
amongst the parameter values.  In order for <a class="reference internal" href="#fit-dream"><span class="std std-ref">DREAM</span></a> to return the
correct uncertainy, the function to be optimized should be a conditional
probability density, with <em>nllf</em> as the negative log likelihood function
of seeing point <span class="math">\(x\)</span> in the parameter space.  Other functions
can be fitted, but uncertainty estimates will be meaningless.</p>
<p>Most algorithms have been adapted to run in parallel at least to some degree.
The  implementation is not heavily tuned, either in terms of minimizing the
overhead per function evaluation or for distributing the problem across
multiple processors.   If the theory function is implemented in parallel,
then the optimizer should be run in serial.  Mixed mode is also possible
when running on a cluster with a multi-threaded theory function.  In this
case, only one theory function will be evaluated on each cluster node, but
the optimizer will distribute the parameters values to the cluster nodes
in parallel.  Do not run serial algorithms (<a class="reference internal" href="#fit-lm"><span class="std std-ref">Levenberg-Marquardt</span></a>, <a class="reference internal" href="#fit-newton"><span class="std std-ref">Quasi-Newton BFGS</span></a>) on
a cluster.</p>
<p>We have included a number of optimizers in Bumps that did not perform
particularly well on our problem sets.  However, they may be perfect
for your problem, so we have left them in the package for you to explore.
They are not available in the GUI selection.</p>
<div class="section" id="levenberg-marquardt">
<span id="fit-lm"></span><h2>Levenberg-Marquardt</h2>
<img alt="Levenberg-Marquardt option screen." class="align-left" src="../../../../_images/fit-lm.png" />
<p>The Levenberg-Marquardt algorithm has been
the standard method for non-linear data fitting.  As a gradient descent
trust region method, it starts at the initial value of the function and
steps in the direction of the derivative until it reaches the minimum.
Set up as an explicit minimization of the sum of square differences between
theory and model, it uses a numerical approximation of the Jacobian matrix
to set the step direction and an adaptive algorithm to set the size of
the trust region.</p>
<div class="section" id="when-to-use">
<h3>When to use</h3>
<p>Use this method when you have a reasonable fit near the minimum, and
you want to get the best possible value.  This can then be used as the starting
point for uncertainty analysis using <a class="reference internal" href="#fit-dream"><span class="std std-ref">DREAM</span></a>.  This method requires
that the problem definition includes a <em>residuals</em> method, but this should
always be true when fitting data.</p>
<p>When modeling the results of an experiment, the best fit value is an
accident of the measurement.  Redo the same measurement, and the slightly
different values you measure will lead to a different best fit.  The
important quantity to report is the credible interval covering
68%  (1-<span class="math">\(\sigma\)</span>) or 95% (2-<span class="math">\(\sigma\)</span>) of the range of
parameter values that are somewhat consistent with the data.</p>
<p>This method uses <em>lmfit</em> from <em>scipy</em>, and does not run in parallel.</p>
</div>
<div class="section" id="options">
<h3>Options</h3>
<p><em>Steps</em> is the number of gradient steps to take.  Each step requires
a calculation of the Jacobian matrix to determine the direction.  This
needs <span class="math">\(2 m n\)</span> function evaluations, where <span class="math">\(n\)</span> is the number of parameters and
each function is evaluated and <span class="math">\(m\)</span> data points (assuming center point
formula for finite difference estimate of the derivative).  The resulting
linear equation is then solved, but for small <span class="math">\(n\)</span> and expensive function
evaluation this overhead can be ignored.  Use <code class="docutils literal"><span class="pre">--steps=n</span></code> from
the command line.</p>
<p><em>f(x) tolerance</em> and <em>x tolerance</em> are used to determine when
the fit has reached the point where no significant improvement is expected.
If the function value does not improve significantly within the step, or
the step is too short, then the fit will terminate.  Use <code class="docutils literal"><span class="pre">--ftol=v</span></code> and
<code class="docutils literal"><span class="pre">--xtol=v</span></code> from the command line.</p>
<p>From the command line, <code class="docutils literal"><span class="pre">--starts=n</span></code> will automatically restart the algorithm
after it has converged so that a slightly better value can be found. If
<code class="docutils literal"><span class="pre">--keep_best</span></code> is included then restart will use a value near the minimum,
otherwise it will restart the fit from a random point in the parameter space.</p>
<p>Use <code class="docutils literal"><span class="pre">--fit=lm</span></code> to select the Levenberg-Marquardt fitter from the command line.</p>
</div>
<div class="section" id="references">
<h3>References</h3>
<table class="docutils citation" frame="void" id="levenberg1944" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Levenberg1944]</td><td>Levenberg, K.
<em>Quarterly Journal of Applied Mathmatics</em>
1944, II (2), 164–168.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="marquardt1963" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Marquardt1963]</td><td>Marquardt, D. W.
<em>Journal of the Society for Industrial and Applied Mathematics</em>
1963, 11 (2), 431–441.
DOI: <a class="reference external" href="http://dx.doi.org/10.1137/0111030">10.1137/0111030</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="nelder-mead-simplex">
<span id="fit-amoeba"></span><h2>Nelder-Mead Simplex</h2>
<img alt="Nelder-Mead Simplex option screen." class="align-left" src="../../../../_images/fit-amoeba.png" />
<p>The Nelder-Mead downhill simplex algorithm is a robust optimizer which
does not require the function to be continuous or differentiable.
It uses the relative values of the function at the corners of a
simplex (an n-dimensional triangle) to decide which points of the simplex
to update.  It will take the worst value and try moving it inward or
outward, or reflect it through the centroid of the remaining values
stopping if it finds a better value.  If none of these values are
better, then it will shrink the simplex and start again.  The name
amoeba comes from the book <em>Numerical Recipes</em> <a class="reference internal" href="#press1992" id="id2">[Press1992]</a> wherein they
describe the search as acting like an amoeba, squeezing through narrow valleys
as it makes its way down to the minimum.</p>
<div class="section" id="id3">
<h3>When to use</h3>
<p>Use this method as a first fit to your model.  If your fitting function
is well behaved with few local minima this will give a quick estimate of
the model, and help you decide if the model needs to be refined.  If your
function is poorly behaved, you will need to select a good initial value
before fitting, or use a more robust method such
as <a class="reference internal" href="#fit-de"><span class="std std-ref">Differential Evolution</span></a> or <a class="reference internal" href="#fit-dream"><span class="std std-ref">DREAM</span></a>.</p>
<p>The uncertainty reported comes from a numerical derivative estimate at the
minimum.</p>
<p>This method requires a series of function updates, and does not benefit
much from running in parallel.</p>
</div>
<div class="section" id="id4">
<h3>Options</h3>
<p><em>Steps</em> is the simplex update iterations to perform.  Most updates
require one or two function evaluations, but shrinking the simplex evaluates
every value in the simplex. Use <code class="docutils literal"><span class="pre">--steps=n</span></code> from the command line.</p>
<p><em>Starts</em> tells the optimizer to restart a given number of times.
Each time it restarts it uses a random starting point.   Use
<code class="docutils literal"><span class="pre">--starts=n</span></code> from the command line.</p>
<p><em>Simplex radius</em> is the initial size of the simplex, as a portion of
the bounds defining the parameter space.  If a parameter is unbounded, then
the radius will be treated as a portion of the parameter value. Use
<code class="docutils literal"><span class="pre">--radius=n</span></code> from the command line.</p>
<p><em>x tolerance</em> and <em>f(x) tolerance</em> are used to determine when the
fit has reached the point where no significant improvement is expected.
If the simplex is tiny (that is, the corners are close to each other) and
flat (that is, the values at the corners are close to each other),
then the fit will terminate.  Use <code class="docutils literal"><span class="pre">--xtol=v</span></code> and <code class="docutils literal"><span class="pre">--ftol=v</span></code> from
the command line.</p>
<p>From the command line, use <code class="docutils literal"><span class="pre">--keep_best</span></code> so that restarts are centered on a
value near the minimum rather than restarting from a random point within the
parameter bounds.</p>
<p>Use <code class="docutils literal"><span class="pre">--fit=amoeba</span></code> to select the Nelder-Mead simplex fitter from the
command line.</p>
</div>
<div class="section" id="id5">
<h3>References</h3>
<table class="docutils citation" frame="void" id="nelder1965" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Nelder1965]</td><td>Nelder, J. A.; Mead, R.
<em>The Computer Journal</em>
1965, 7 (4), 308–313.
DOI: <a class="reference external" href="http://dx.doi.org/10.1093/comjnl/7.4.308">10.1093/comjnl/7.4.308</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="press1992" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[Press1992]</a></td><td>Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; Vetterling, W. T.
In <em>Numerical Recipes in C: The Art of Scientific Computing, Second Edition</em>;
Cambridge University Press: Cambridge; New York, 1992; pp 408–412.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="quasi-newton-bfgs">
<span id="fit-newton"></span><h2>Quasi-Newton BFGS</h2>
<img alt="Quasi-Newton BFGS option screen." class="align-left" src="../../../../_images/fit-newton.png" />
<p>Broyden-Fletcher-Goldfarb-Shanno is a gradient descent method which uses the
gradient to determine the step direction and an approximation of the Hessian
matrix to estimate the curvature and guess a step size.  The step is further
refined with a one-dimensional search in the direction of the gradient.</p>
<div class="section" id="id6">
<h3>When to use</h3>
<p>Like <a class="reference internal" href="#fit-lm"><span class="std std-ref">Levenberg-Marquardt</span></a>, this method converges quickly to the minimum.  It does
not assume that the problem is in the form of a sum of squares and does not
require a <em>residuals</em> method.</p>
<p>The <span class="math">\(n\)</span> partial derivatives are computed in parallel.</p>
</div>
<div class="section" id="id7">
<h3>Options</h3>
<p><em>Steps</em> is the number of gradient steps to take.  Each step requires
a calculation of the Jacobian matrix to determine the direction.  This
needs <span class="math">\(2 m n\)</span> function evaluations, where <span class="math">\(n\)</span> is the number of parameters and
each function is evaluated and <span class="math">\(m\)</span> data points (assuming center point
formula for finite difference estimate of the derivative).  The resulting
linear equation is then solved, but for small <span class="math">\(n\)</span> and expensive function
evaluation this overhead can be ignored.
Use <code class="docutils literal"><span class="pre">--steps=n</span></code> from the command line.</p>
<p><em>Starts</em> tells the optimizer to restart a given number of times.
Each time it restarts it uses a random starting point.
Use <code class="docutils literal"><span class="pre">--starts=n</span></code> from the command line.</p>
<p><em>f(x) tolerance</em> and <em>x tolerance</em> are used to determine when
the fit has reached the point where no significant improvement is expected.
If the function is small or the step is too short then the fit
will terminate.  Use <code class="docutils literal"><span class="pre">--ftol=v</span></code> and <code class="docutils literal"><span class="pre">--xtol=v</span></code> from the command line.</p>
<p>From the command line, <code class="docutils literal"><span class="pre">--keep_best</span></code> uses a value near the previous minimum
when restarting instead of using a random value within the parameter bounds.</p>
<p>Use <code class="docutils literal"><span class="pre">--fit=newton</span></code> to select BFGS from the commandline.</p>
</div>
<div class="section" id="id8">
<h3>References</h3>
<table class="docutils citation" frame="void" id="dennis1987" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Dennis1987]</td><td>Dennis, J. E.; Schnabel, R. B.
<em>Numerical Methods for Unconstrained Optimization and Nonlinear Equations</em>;
Society for Industrial and Applied Mathematics: Philadelphia, 1987.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="differential-evolution">
<span id="fit-de"></span><h2>Differential Evolution</h2>
<img alt="Differential Evolution option screen." class="align-left" src="../../../../_images/fit-de.png" />
<p>Differential evolution is a population based algorithm which uses differences
between points as a guide to selecting new points.  For each member of the
population a pair of points is chosen at random, and a difference vector is
computed.  This vector is scaled, and a random subset of its components are
added to the current point based on crossover ratio. This new point is
evaluated, and if its value is lower than the current point, it replaces
it in the population.   There are many variations available within DE that
have not been exposed in Bumps.  Interested users can modify
<code class="xref py py-class docutils literal"><span class="pre">bumps.fitters.DEFit</span></code> and experiment with different crossover and
mutation algorithms, and perhaps add them as command line options.</p>
<p>Differential evolution is a robust directed search strategy.  Early in the
search, when the population is disperse, the difference vectors are large
and the search remains broad.  As the search progresses, more of the
population goes into the valleys and eventually all the points end up in
local minima.  Now the differences between random pairs will often be small
and the search will become more localized.</p>
<p>The population is initialized according to the prior probability distribution
for each each parameter.  That is, if the parameter is bounded, it will use
a uniform random number generate within the bounds.  If it is unbounded, it
will use a uniform value in [0,1].  If the parameter corresponds to the result
of a previous measurement with mean <span class="math">\(\mu\)</span> and standard deviation <span class="math">\(\sigma\)</span>,
then the initial values will be pulled from a gaussian random number generator.</p>
<div class="section" id="id9">
<h3>When to use</h3>
<p>Convergence with differential evolution will be slower, but more robust.</p>
<p>Each update will evaluate <span class="math">\(k\)</span> points in parallel, where <span class="math">\(k\)</span> is the size
of the population.</p>
</div>
<div class="section" id="id10">
<h3>Options</h3>
<p><em>Steps</em> is the number of iterations.  Each step updates each member
of the population.  The population size scales with the number of fitted
parameters. Use <code class="docutils literal"><span class="pre">--steps=n</span></code> from the command line.</p>
<p><em>Population</em> determines the size of the population.  The number of
individuals, <span class="math">\(k\)</span>, is equal to the number of fitted parameters times the
population scale factor.  Use <code class="docutils literal"><span class="pre">--pop=k</span></code> from the command line.</p>
<p><em>Crossover ratio</em> determines what proportion of the dimensions to update
at each step.  Smaller values will likely lead to slower convergence, but
more robust results.  Values must be between 0 and 1.  Use <code class="docutils literal"><span class="pre">--CR=v</span></code> from
the command line.</p>
<p><em>Scale</em> determines how much to scale each difference vector before adding
it to the candidate point.  The selected mutation algorithm chooses a scale
factor uniformly in <span class="math">\([0,F]\)</span>.  Use <code class="docutils literal"><span class="pre">--F=v</span></code> from the command line.</p>
<p><em>f(x) tolerance</em> and <em>x tolerance</em> are used to determine when the
fit has reached the point where no significant improvement is expected.
If the population is flat (that is, the minimum and maximum values are
within tolerance) and tiny (that is, all the points are close to each
other) then the fit will terminate.  Use <code class="docutils literal"><span class="pre">ftol=v</span></code> and <code class="docutils literal"><span class="pre">xtol=v</span></code> from the
command line.</p>
<p>Use <code class="docutils literal"><span class="pre">--fit=de</span></code> to select diffrential evolution from the commandline.</p>
</div>
<div class="section" id="id11">
<h3>References</h3>
<table class="docutils citation" frame="void" id="storn1997" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Storn1997]</td><td>Storn, R.; Price, K.
<em>Journal of Global Optimization</em>
1997, 11 (4), 341–359.
DOI: <a class="reference external" href="http://dx.doi.org/10.1023/A:1008202821328">10.1023/A:1008202821328</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="dream">
<span id="fit-dream"></span><h2>DREAM</h2>
<img alt="DREAM option screen." class="align-left" src="../../../../_images/fit-dream.png" />
<p>DREAM is a population based algorithm like differential evolution, but
instead of only keeping individuals which improve each generation, it
will sometimes keep individuals which get worse.  Although it is not
fast and does not give the very best value for the function, we have
found it to be a robust fitting engine which will give a good value given
enough time.</p>
<p>The progress of each individual in the population from generation to
generation can considered a Markov chain, whose transition probability
is equal to the probability of taking the step times the probability
that it keeps the step based on the difference in value between the points.
By including a purely random stepper with some probability, the detailed
balance condition is preserved, and the Markov chain converges onto
the underlying equilibrium distribution.  If the theory function represents
the conditional probability of selecting each point in the parameter
space, then the resulting chain is a random draw from the posterior
distribution.</p>
<p>This means that the DREAM algorithm can be used to determine the parameter
uncertainties.  Unlike the hessian estimate at the minimum that is
used to report uncertainties from the other fitters, the resulting
uncertainty need not gaussian.  Indeed, the resulting distribution can
even be multi-modal.  Fits to measured data using theory functions that
have symmetric solutions have shown all equivalent solutions with approximately
equal probability.</p>
<div class="section" id="id12">
<h3>When to use</h3>
<p>Use DREAM when you need a robust fitting algorithm.  It takes longer but
it does an excellent job of exploring different minima and getting close
to the global optimum.</p>
<p>Use DREAM when you want a detailed analysis of the parameter uncertainty.</p>
<p>Like differential evolution, DREAM will evaluate <span class="math">\(k\)</span> points in parallel,
where <span class="math">\(k\)</span> is the size of the population.</p>
</div>
<div class="section" id="id13">
<h3>Options</h3>
<p><em>Samples</em> is the number of points to be drawn from the Markov chain.
To estimate the 68% interval to two digits of precision, at least
1e5 (or 100,000) samples are needed.  For the 95% interval, 1e6
(or 1,000,000) samples are needed.  The default 1e4 samples
gives a rough approximation of the uncertainty relatively quickly.
Use <code class="docutils literal"><span class="pre">--samples=n</span></code> from the command line.</p>
<p><em>Burn-in Steps</em> is the number of iterations to required for the Markov
chain to converge to the equilibrium distribution.  If the fit ends
early, the tail of the burn will be saved to the start of the steps.
Use <code class="docutils literal"><span class="pre">--burn=n</span></code> from the command line.</p>
<p><em>Population</em> determines the size of the population.  The number of
individuals, <span class="math">\(k\)</span>, is equal to the number of fitted parameters times the
population scale factor.  Use <code class="docutils literal"><span class="pre">--pop=k</span></code> from the command line.</p>
<p><em>Initializer</em> determines how the population will be initialized.
The options are as follows:</p>
<blockquote>
<div><p><em>eps</em> (epsilon ball), in which the entire initial population is chosen
at random from within a tiny hypersphere centered about the initial point</p>
<p><em>lhs</em> (latin hypersquare), which chops the bounds within each dimension
in <span class="math">\(k\)</span> equal sized chunks where <span class="math">\(k\)</span> is the size of the population and
makes sure that each parameter has at least one value within each chunk
across the population.</p>
<p><em>cov</em> (covariance matrix), in which the uncertainty is estimated using
the covariance matrix at the initial point, and points are selected
at random from the corresponding gaussian ellipsoid</p>
<p><em>random</em> (uniform random), in which the points are selected at random
within the bounds of the parameters</p>
</div></blockquote>
<p>Use <code class="docutils literal"><span class="pre">--init=type</span></code> from the command line.</p>
<p><em>Thinning</em> is the amount of thinning to use when collecting the
population.  If the fit is somewhat stuck, with most steps not improving
the fit, then you will need to thin the population to get proper
statistics.  Use <code class="docutils literal"><span class="pre">--thin=k</span></code> from the command line.</p>
<p><em>Calculate entropy</em>, if true, computes the entropy for the fit.  This is
an estimate of the amount of information in the data.  Use <code class="docutils literal"><span class="pre">--entropy</span></code>
from the command line.</p>
<p><em>Steps</em>, if not zero, determines the number of iterations to use for
drawing samples after burn in. Each iteration updates the full population,
which is (population x number of fitted parameters) points. This option
is available for compatibility; it is more useful to set the number of
samples directly.  Use <code class="docutils literal"><span class="pre">--steps=n</span></code> from the command line.</p>
<p>Use <code class="docutils literal"><span class="pre">--fit=dream</span></code> to select DREAM from the commandline.</p>
</div>
<div class="section" id="output">
<h3>Output</h3>
<p>DREAM produces a number of different outputs, and there are a number of
things to check before using its reported uncertainty values.  The main
goal of selecting <code class="docutils literal"><span class="pre">--burn=n</span></code> is to wait long enough to reach the
equilibrium distribution.</p>
<div class="figure" id="id24">
<img alt="example of incomplete fit" src="../../../../_images/dream-incomplete.png" />
<p class="caption"><span class="caption-number">Fig. 114 </span><span class="caption-text">This DREAM fit is incomplete, as can be seen on all four plots.  The
<em>Convergence</em> plot is still decreasing, <em>Parameter Trace</em> plot does not
show random mixing of Markov chain values, the <em>Correlations</em> plots are
fuzzy and mostly empty, the <em>Uncertainty</em> plot shows black histograms
(indicating that there are a few stray values far away from the best) and
green maximum likelihood spikes not matching the histogram (indicating
that the region around the best value has not been adequately explored).</span></p>
</div>
<div class="figure" id="id25">
<img alt="example of a completed fit" src="../../../../_images/dream-complete.png" />
<p class="caption"><span class="caption-number">Fig. 115 </span><span class="caption-text">This DREAM fit completed successfully.  The <em>Convergence</em> plot is flat,
the <em>Parameter Trace</em> plot is flat and messy, the <em>Correlateions</em> plots
show nice blobs (and a bit of correlation between the <em>M1.radius</em> parameter
and the <em>M1.radius.width</em> parameter), and the uncertainty plots show
a narrow range of -log(P) values in the mostly brown histograms and
a good match to the green constrained maximum likelihood line.</span></p>
</div>
<p>For each parameter in the fit, DREAM finds the mean, median and best value,
as well as the 68% and 95% credible intervals.  The mean value is
defined as <span class="math">\(\int x P(x) dx\)</span>, which is just the expected value of the
probability distribution for the parameter.  The median value is the 50%
point in the probability distribution, and the best value is the maximum
likelihood value seen in the random walk.  The credible intervals are the
central intervals which capture 68% and 95% of the parameter values
respectively.  You need approximately 100,000 samples to get two digits of
precision on the 68% interval, and 1,000,000 samples for the 95% interval.</p>
<table border="1" class="docutils" id="id26">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Example fit output</caption>
<colgroup>
<col width="1%" />
<col width="19%" />
<col width="15%" />
<col width="10%" />
<col width="10%" />
<col width="22%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Parameter</th>
<th class="head">mean</th>
<th class="head">median</th>
<th class="head">best</th>
<th class="head">[   68% interval]</th>
<th class="head">[   95% interval]</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>M1.background</td>
<td>0.059925(41)</td>
<td>0.059924</td>
<td>0.059922</td>
<td>[0.05988 0.05997]</td>
<td>[0.05985 0.06000]</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>M1.radius</td>
<td>2345.3(15)</td>
<td>2345.234</td>
<td>2345.174</td>
<td>[2343.83 2346.74]</td>
<td>[2342.36 2348.29]</td>
</tr>
<tr class="row-even"><td>3</td>
<td>M1.radius.width</td>
<td>0.00775(41)</td>
<td>0.00774</td>
<td>0.00777</td>
<td>[ 0.0074  0.0081]</td>
<td>[ 0.0070  0.0086]</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>M1.scale</td>
<td>0.21722(20)</td>
<td>0.217218</td>
<td>0.217244</td>
<td>[0.21702 0.21743]</td>
<td>[0.21681 0.21761]</td>
</tr>
</tbody>
</table>
<p>The <em>Convergence</em> plot shows the range of <span class="math">\(\chi^2\)</span> values in the population
for each iteration.  The band shows the 68% of values around the median, and
the solid line shows the minimum value.  If the distribution has reached
equilibrium, then convergence graph should be roughly flat, with little
change in the minimum value throughout the graph.  If there is no convergence,
then the remaining plots don&#8217;t mean much.</p>
<p>The <em>Correlations</em> plot shows cross correlation between each pair of
parameters.  If the parameters are completely uncorrelated then the boxes
should contain circles.  Diagonals indicate strong correlation.  Square
blocks indicate that the fit is not sensitive to one of the parameters.
The range plotted on the correlation plot is determined by the 95% interval
of the data.  The individual correlation plots are too small to show the
range of values for the parameters.  These can instead be read from the
<em>Uncertainty</em> plot for each parameter, which covers the same range of values
and indicates 68% and 95% intervals.  If there are some chains that are
wandering around away from the minimum, then the plot will look fuzzy, and
not have a nice blob in the center.  If a correlation plot has multiple blobs,
then there are multiple minima in your problem space, usually because there
are symmetries in the problem definition.  For example, a model fitting
<span class="math">\(x + a^2\)</span> will have identical solutions for <span class="math">\(\pm\,a\)</span>.</p>
<p>The <em>Uncertainty</em> plot shows histograms for each fitted parameter generated
from the values for that parameter across all chains.  Within each histogram
bar the values are sorted and displayed as a gradient from black to copper,
with black values having the lowest <span class="math">\(\chi^2\)</span> and copper values having the
highest.  The resulting histogram should be dark brown, with a black hump
in the center and light brown tips.  If there are large lumps of light brown,
or excessive black then its likely that the optimizer did not converge.  The
green line over the histogram shows the best value seen within each
histogram bin (the maximum likelihood given <span class="math">\(p_k == x\)</span>).
With enough samples and proper convergence, it should roughly follow the
outline of the histogram.  The yellow band in the center of the plot
represents the 68% interval for the data.  The histogram cuts off at 95%.
These values along with the median are shown as labels along the x axis.
The green asterisk represents the best value, the green <em>E</em> the mean value
and the vertical green line the median value.  If the fit is not sensitive
to a parameter, or if two parameters are strongly correlated, the parameter
histogram will show a box rather than a hump.  Spiky shapes (either in the
histogram or the maximum likelihood line) indicate lack of convergence or
maybe not enough steps.  A chopped histograms indicates that the range for
that parameter is too small.</p>
<p>The <em>Parameter Trace</em> plot is diagnostic for models which have poor mixing.
In this cases no matter how the parameter values are changing, they are
landing on much worse values for the <span class="math">\(\chi^2\)</span>.  This can happen if the
problem is highly constrained with many tight and twisty values.</p>
<p>The <em>Data and Theory</em> plot should show theory and data lining up pretty well,
with the theory overlaying about 2/3 of the error bars on the data
(1-<span class="math">\(\sigma\)</span> = 68%).  The <em>Residuals</em> plot shows the difference between
theory and data divided by uncertainty.  The residuals should be 2/3 within
[-1, 1], They should not show any structure, such as humps where the theory
misses the data for long stretches.  This indicates some feature missing
from the model, or a lack of convergence to the best model.</p>
<p>If entropy is requested, then bumps will show the total number of bits of
information in the fit.  This derives from the entropy term:</p>
<p>Using entropy and simulation we hope to be able to make experiment
planning decisions in a way that maximizes information, by estimating
whether it is better to measure more precisely or to measure different
but related values and fit them with shared parameters.</p>
</div>
<div class="section" id="id14">
<h3>References</h3>
<table class="docutils citation" frame="void" id="vrugt2009" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Vrugt2009]</td><td>Vrugt, J. A.; Ter Braak, C. J. F.; Diks, C. G. H.; Robinson, B. A.;
Hyman, J. M.; Higdon, D.
<em>International Journal of Nonlinear Sciences and Numerical Simulation</em>
2009, 10 (3), 273–290.
DOI: <a class="reference external" href="http://dx.doi.org/10.1515/IJNSNS.2009.10.3.273">10.1515/IJNSNS.2009.10.3.273</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="kramer2010" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Kramer2010]</td><td>Kramer, A.; Hasenauer, J.; Allgower, F.; Radde, N.
<em>In 2010 IEEE International Conference on Control Applications (CCA)</em>
2010; pp 493–498.
DOI: <a class="reference external" href="http://dx.doi.org/10.1109/CCA.2010.5611198">10.1109/CCA.2010.5611198</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="jcgm2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[JCGM2008]</td><td>JCGM.
<em>Evaluation of measurement data — Supplement 1 to the “Guide to the
expression of uncertainty in measurement” — Propagation of distributions
using a Monte Carlo method</em>; Joint Committee for Guides in Metrology,
JCGM 101:2008; Geneva, Switzerland, 2008; p 90.
<a class="reference external" href="http://www.bipm.org/utils/common/documents/jcgm/JCGM_101_2008_E.pdf">http://www.bipm.org/utils/common/documents/jcgm/JCGM_101_2008_E.pdf</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="particle-swarm">
<span id="fit-ps"></span><h2>Particle Swarm</h2>
<p>Inspired by bird flocking behaviour, the particle swarm algorithm is a
population-based method which updates an individual according to its
momentum and a force toward the current best fit parameter values.  We
did not explore variations of this algorithm in any detail.</p>
<div class="section" id="id15">
<h3>When to use</h3>
<p>Particle swarm performed well enough in our low dimensional test problems,
but made little progress when more fit parameters were added.</p>
<p>The population updates can run in parallel, but the tiny population size
limits the amount of parallelism.</p>
</div>
<div class="section" id="id16">
<h3>Options</h3>
<p><code class="docutils literal"><span class="pre">--steps=n</span></code> is the number of iterations.  Each step updates each member
of the population.  The population size scales with the number of fitted
parameters.</p>
<p><code class="docutils literal"><span class="pre">--pop=k</span></code> determines the size of the population.  The number of
individuals, <span class="math">\(k\)</span>, is equal to the number of fitted parameters times the
population scale factor.  The default scale factor is 1.</p>
<p>Use <code class="docutils literal"><span class="pre">--fit=ps</span></code> to select particle swarm from the commandline.</p>
<p>Add a few more lines</p>
</div>
<div class="section" id="id17">
<h3>References</h3>
<table class="docutils citation" frame="void" id="kennedy1995" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Kennedy1995]</td><td>Kennedy, J.; Eberhart, R.
Particle Swarm Optimization
<em>Proceedings of IEEE International Conference on Neural Networks. IV.</em>
1995; pp 1942–1948.
DOI: <a class="reference external" href="http://dx.doi.org/810.1109/ICNN.1995.488968">10.1109/ICNN.1995.48896</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="random-lines">
<span id="fit-rl"></span><h2>Random Lines</h2>
<p>Most of the population based algorithms ignore the value of the function
when choosing the points in the next iteration.  Random lines is a new
style of algorithm which fits a quadratic model to a selection from the
population, and uses that model to propose a new point in the next
generation of the population.  The hope is that the method will inherit
the robustness of the population based algorithms as well as the rapid
convergence of the newton descent algorithms.</p>
<div class="section" id="id18">
<h3>When to use</h3>
<p>Random lines works very well for some of our test problems, showing
rapid convergence to the optimum, but on other problems it makes
very little progress.</p>
<p>The population updates can run in parallel.</p>
</div>
<div class="section" id="id19">
<h3>Options</h3>
<p><code class="docutils literal"><span class="pre">--steps=n</span></code> is the number of iterations.  Each step updates each member
of the population.  The population size scales with the number of fitted
parameters.</p>
<p><code class="docutils literal"><span class="pre">--pop=k</span></code> determines the size of the population.  The number of
individuals, <span class="math">\(k\)</span>, is equal to the number of fitted parameters times the
population scale factor.  The default scale factor is 0.5.</p>
<p><code class="docutils literal"><span class="pre">--CR=v</span></code> is the crossover ratio, determining what proportion of the
dimensions to update at each step.  Values must be between 0 and 1.</p>
<p><code class="docutils literal"><span class="pre">--starts=n</span></code> tells the optimizer to restart a given number of times.
Each time it restarts it uses a random starting point.</p>
<p><code class="docutils literal"><span class="pre">--keep_best</span></code> uses a value near the previous minimum when restarting
instead of using a random value within the parameter bounds.  This option is
not available in the options dialog.</p>
<p>Use <code class="docutils literal"><span class="pre">--fit=rl</span></code> to select random lines from the commandline.</p>
</div>
<div class="section" id="id20">
<h3>References</h3>
<table class="docutils citation" frame="void" id="sahin2013" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Sahin2013]</td><td>Sahin, I.
<em>An International Journal of Optimization and Control:  Theories &amp; Applications (IJOCTA)</em>
2013, 3 (2), 111–119.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="parallel-tempering">
<span id="fit-pt"></span><h2>Parallel Tempering</h2>
<p>Parallel tempering is an MCMC algorithm for uncertainty analysis.  This
version runs at multiple temperatures simultaneously, with chains at high
temperature able to more easily jump between minima and chains at low
temperature to fully explore the minima.  Like <a class="reference internal" href="#fit-dream"><span class="std std-ref">DREAM</span></a> it has a
differential evolution stepper, but this version uses the chain history
as the population rather than maintaining a population at each temperature.</p>
<p>This is an experimental algorithm which does not yet perform well.</p>
<div class="section" id="id21">
<h3>When to use</h3>
<p>When complete, parallel tempering should be used for problems with widely
spaced local minima which dream cannot fit.</p>
</div>
<div class="section" id="id22">
<h3>Options</h3>
<p><code class="docutils literal"><span class="pre">--steps=n</span></code> is the number of iterations to include in the Markov
chain.  Each iteration updates the full population.  The population size
scales with the number of fitted parameters.</p>
<p><code class="docutils literal"><span class="pre">--burn=n</span></code> is the number of iterations to required for the Markov
chain to converge to the equilibrium distribution.  If the fit ends
early, the tail of the burn will be saved to the start of the steps.</p>
<p><code class="docutils literal"><span class="pre">--CR=v</span></code> is the differential evolution crossover ratio to use when
computing step size and direction.  Use a small value to step through the
dimensions one at a time, or a large value to step through all at once.</p>
<p><code class="docutils literal"><span class="pre">-nT=k</span></code>, <code class="docutils literal"><span class="pre">-Tmin=v</span></code> and <code class="docutils literal"><span class="pre">--Tmax=v</span></code> specify a log-spaced initial
distribution of temperatures.  The default is 25 points between
0.1 and 10.  <a class="reference internal" href="#fit-dream"><span class="std std-ref">DREAM</span></a> runs at a fixed temperature of 1.0.</p>
<p>Use <code class="docutils literal"><span class="pre">--fit=pt</span></code> to select parallel tempering from the commandline.</p>
</div>
<div class="section" id="id23">
<h3>References</h3>
<table class="docutils citation" frame="void" id="swendsen1986" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Swendsen1986]</td><td>Swendsen, R. H.; Wang J. S.
Replica Monte Carlo simulation of spin glasses
<em>Physical Review Letters</em>
1986, 57, 2607-2609</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Optimizer Selection</a><ul>
<li><a class="reference internal" href="#levenberg-marquardt">Levenberg-Marquardt</a><ul>
<li><a class="reference internal" href="#when-to-use">When to use</a></li>
<li><a class="reference internal" href="#options">Options</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nelder-mead-simplex">Nelder-Mead Simplex</a><ul>
<li><a class="reference internal" href="#id3">When to use</a></li>
<li><a class="reference internal" href="#id4">Options</a></li>
<li><a class="reference internal" href="#id5">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#quasi-newton-bfgs">Quasi-Newton BFGS</a><ul>
<li><a class="reference internal" href="#id6">When to use</a></li>
<li><a class="reference internal" href="#id7">Options</a></li>
<li><a class="reference internal" href="#id8">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#differential-evolution">Differential Evolution</a><ul>
<li><a class="reference internal" href="#id9">When to use</a></li>
<li><a class="reference internal" href="#id10">Options</a></li>
<li><a class="reference internal" href="#id11">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dream">DREAM</a><ul>
<li><a class="reference internal" href="#id12">When to use</a></li>
<li><a class="reference internal" href="#id13">Options</a></li>
<li><a class="reference internal" href="#output">Output</a></li>
<li><a class="reference internal" href="#id14">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#particle-swarm">Particle Swarm</a><ul>
<li><a class="reference internal" href="#id15">When to use</a></li>
<li><a class="reference internal" href="#id16">Options</a></li>
<li><a class="reference internal" href="#id17">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#random-lines">Random Lines</a><ul>
<li><a class="reference internal" href="#id18">When to use</a></li>
<li><a class="reference internal" href="#id19">Options</a></li>
<li><a class="reference internal" href="#id20">References</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parallel-tempering">Parallel Tempering</a><ul>
<li><a class="reference internal" href="#id21">When to use</a></li>
<li><a class="reference internal" href="#id22">Options</a></li>
<li><a class="reference internal" href="#id23">References</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="mag_help.html"
                        title="previous chapter">Polarisation/Magnetic Scattering</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../../../sans_to_sesans.html"
                        title="next chapter">SANS to SESANS conversion</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/user/sasgui/perspectives/fitting/optimizer.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../sans_to_sesans.html" title="SANS to SESANS conversion"
             >next</a> |</li>
        <li class="right" >
          <a href="mag_help.html" title="Polarisation/Magnetic Scattering"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SasView 4.1.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../user.html" >SasView User Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../../../analysis.html" >Fitting &amp; Other Analyses</a> &raquo;</li>
          <li class="nav-item nav-item-3"><a href="fitting.html" >Fitting Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2017, The SasView Project.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>