<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sas.dataloader.manipulations &mdash; SasView 3.1.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="SasView 3.1.2 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SasView 3.1.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sas.dataloader.manipulations</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Data manipulations for 2D data sets.</span>
<span class="sd">Using the meta data information, various types of averaging</span>
<span class="sd">are performed in Q-space</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c">#####################################################################</span>
<span class="c">#This software was developed by the University of Tennessee as part of the</span>
<span class="c">#Distributed Data Analysis of Neutron Scattering Experiments (DANSE)</span>
<span class="c">#project funded by the US National Science Foundation.</span>
<span class="c">#See the license text in license.txt</span>
<span class="c">#copyright 2008, University of Tennessee</span>
<span class="c">######################################################################</span>

<span class="c">#TODO: copy the meta data from the 2D object to the resulting 1D object</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c">#from data_info import plottable_2D</span>
<span class="kn">from</span> <span class="nn">data_info</span> <span class="kn">import</span> <span class="n">Data1D</span>


<div class="viewcode-block" id="get_q"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.get_q">[docs]</a><span class="k">def</span> <span class="nf">get_q</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">det_dist</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param dx: x-distance from beam center [mm]</span>
<span class="sd">    :param dy: y-distance from beam center [mm]</span>
<span class="sd">    :return: q-value at the given position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Distance from beam center in the plane of detector</span>
    <span class="n">plane_dist</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>
    <span class="c"># Half of the scattering angle</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">plane_dist</span> <span class="o">/</span> <span class="n">det_dist</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">wavelength</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="get_q_compo"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.get_q_compo">[docs]</a><span class="k">def</span> <span class="nf">get_q_compo</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">det_dist</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">compo</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This reduces tiny error at very large q.</span>
<span class="sd">    Implementation of this func is not started yet.&lt;--ToDo</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">angle_xy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">angle_xy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">angle_xy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">dx</span> <span class="o">/</span> <span class="n">dy</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">compo</span> <span class="o">==</span> <span class="s">&quot;x&quot;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">get_q</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">det_dist</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle_xy</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">compo</span> <span class="o">==</span> <span class="s">&quot;y&quot;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">get_q</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">det_dist</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle_xy</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">get_q</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">det_dist</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>

</div>
<div class="viewcode-block" id="flip_phi"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.flip_phi">[docs]</a><span class="k">def</span> <span class="nf">flip_phi</span><span class="p">(</span><span class="n">phi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correct phi to within the 0 &lt;= to &lt;= 2pi range</span>

<span class="sd">    :return: phi in &gt;=0 and &lt;=2Pi</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Pi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">if</span> <span class="n">phi</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">phi_out</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Pi</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">phi</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Pi</span><span class="p">):</span>
        <span class="n">phi_out</span> <span class="o">=</span> <span class="n">phi</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Pi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">phi_out</span> <span class="o">=</span> <span class="n">phi</span>
    <span class="k">return</span> <span class="n">phi_out</span>

</div>
<div class="viewcode-block" id="reader2D_converter"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.reader2D_converter">[docs]</a><span class="k">def</span> <span class="nf">reader2D_converter</span><span class="p">(</span><span class="n">data2d</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    convert old 2d format opened by IhorReader or danse_reader</span>
<span class="sd">    to new Data2D format</span>

<span class="sd">    :param data2d: 2d array of Data2D object</span>
<span class="sd">    :return: 1d arrays of Data2D object</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data2d</span><span class="o">.</span><span class="n">data</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">data2d</span><span class="o">.</span><span class="n">x_bins</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">data2d</span><span class="o">.</span><span class="n">y_bins</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;Can&#39;t convert this data: data=None...&quot;</span>
    <span class="n">new_x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">data2d</span><span class="o">.</span><span class="n">x_bins</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data2d</span><span class="o">.</span><span class="n">y_bins</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">new_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">data2d</span><span class="o">.</span><span class="n">y_bins</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data2d</span><span class="o">.</span><span class="n">x_bins</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">new_y</span> <span class="o">=</span> <span class="n">new_y</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">new_data</span> <span class="o">=</span> <span class="n">data2d</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">qx_data</span> <span class="o">=</span> <span class="n">new_x</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">qy_data</span> <span class="o">=</span> <span class="n">new_y</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">q_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qx_data</span> <span class="o">*</span> <span class="n">qx_data</span> <span class="o">+</span> <span class="n">qy_data</span> <span class="o">*</span> <span class="n">qy_data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data2d</span><span class="o">.</span><span class="n">err_data</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data2d</span><span class="o">.</span><span class="n">err_data</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">new_err_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_data</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_err_data</span> <span class="o">=</span> <span class="n">data2d</span><span class="o">.</span><span class="n">err_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c">#TODO: make sense of the following two lines...</span>
    <span class="c">#from sas.dataloader.data_info import Data2D</span>
    <span class="c">#output = Data2D()</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">data2d</span>
    <span class="n">output</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span>
    <span class="n">output</span><span class="o">.</span><span class="n">err_data</span> <span class="o">=</span> <span class="n">new_err_data</span>
    <span class="n">output</span><span class="o">.</span><span class="n">qx_data</span> <span class="o">=</span> <span class="n">qx_data</span>
    <span class="n">output</span><span class="o">.</span><span class="n">qy_data</span> <span class="o">=</span> <span class="n">qy_data</span>
    <span class="n">output</span><span class="o">.</span><span class="n">q_data</span> <span class="o">=</span> <span class="n">q_data</span>
    <span class="n">output</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>

    <span class="k">return</span> <span class="n">output</span>

</div>
<span class="k">class</span> <span class="nc">_Slab</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute average I(Q) for a region of interest</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">y_max</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">bin_width</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
        <span class="c"># Minimum Qx value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="n">x_min</span>
        <span class="c"># Maximum Qx value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="n">x_max</span>
        <span class="c"># Minimum Qy value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="n">y_min</span>
        <span class="c"># Maximum Qy value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">y_max</span>
        <span class="c"># Bin width (step size) [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span> <span class="o">=</span> <span class="n">bin_width</span>
        <span class="c"># If True, I(|Q|) will be return, otherwise,</span>
        <span class="c"># negative q-values are allowed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fold</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">_avg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">,</span> <span class="n">maj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute average I(Q_maj) for a region of interest.</span>
<span class="sd">        The major axis is defined as the axis of Q_maj.</span>
<span class="sd">        The minor axis is the axis that we average over.</span>

<span class="sd">        :param data2D: Data2D object</span>
<span class="sd">        :param maj_min: min value on the major axis</span>
<span class="sd">        :return: Data1D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">detector</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;_Slab._avg: invalid number of &quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot; detectors: </span><span class="si">%g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">detector</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="n">msg</span>

        <span class="c"># Get data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">err_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">err_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">qx_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qx_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">qy_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qy_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>

        <span class="c"># Build array of Q intervals</span>
        <span class="k">if</span> <span class="n">maj</span> <span class="o">==</span> <span class="s">&#39;x&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fold</span><span class="p">:</span>
                <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span>
            <span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">maj</span> <span class="o">==</span> <span class="s">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fold</span><span class="p">:</span>
                <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span>
            <span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="s">&quot;_Slab._avg: unrecognized axis </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">maj</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">err_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">y_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>

        <span class="c"># Average pixelsize in q space</span>
        <span class="k">for</span> <span class="n">npts</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="c"># default frac</span>
            <span class="n">frac_x</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">frac_y</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c"># get ROI</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">&lt;=</span> <span class="n">qx_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">&gt;</span> <span class="n">qx_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]:</span>
                <span class="n">frac_x</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">&lt;=</span> <span class="n">qy_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">&gt;</span> <span class="n">qy_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]:</span>
                <span class="n">frac_y</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">frac</span> <span class="o">=</span> <span class="n">frac_x</span> <span class="o">*</span> <span class="n">frac_y</span>

            <span class="k">if</span> <span class="n">frac</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c"># binning: find axis of q</span>
            <span class="k">if</span> <span class="n">maj</span> <span class="o">==</span> <span class="s">&#39;x&#39;</span><span class="p">:</span>
                <span class="n">q_value</span> <span class="o">=</span> <span class="n">qx_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
                <span class="n">min_value</span> <span class="o">=</span> <span class="n">x_min</span>
            <span class="k">if</span> <span class="n">maj</span> <span class="o">==</span> <span class="s">&#39;y&#39;</span><span class="p">:</span>
                <span class="n">q_value</span> <span class="o">=</span> <span class="n">qy_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
                <span class="n">min_value</span> <span class="o">=</span> <span class="n">y_min</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fold</span> <span class="ow">and</span> <span class="n">q_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">q_value</span> <span class="o">=</span> <span class="o">-</span><span class="n">q_value</span>
            <span class="c"># bin</span>
            <span class="n">i_q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">q_value</span> <span class="o">-</span> <span class="n">min_value</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c"># skip outside of max bins</span>
            <span class="k">if</span> <span class="n">i_q</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i_q</span> <span class="o">&gt;=</span> <span class="n">nbins</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c">#TODO: find better definition of x[i_q] based on q_data</span>
            <span class="c"># min_value + (i_q + 1) * self.bin_width / 2.0</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">q_value</span>
            <span class="n">y</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">err_data</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
                <span class="n">err_y</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err_y</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
            <span class="n">y_counts</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span>

        <span class="c"># Average the sums</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbins</span><span class="p">):</span>
            <span class="n">err_y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err_y</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="n">err_y</span> <span class="o">=</span> <span class="n">err_y</span> <span class="o">/</span> <span class="n">y_counts</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">y_counts</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y_counts</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Average Error: No points inside ROI to average...&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">msg</span>
        <span class="k">return</span> <span class="n">Data1D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dy</span><span class="o">=</span><span class="n">err_y</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>


<div class="viewcode-block" id="SlabY"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.SlabY">[docs]</a><span class="k">class</span> <span class="nc">SlabY</span><span class="p">(</span><span class="n">_Slab</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute average I(Qy) for a region of interest</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute average I(Qy) for a region of interest</span>

<span class="sd">        :param data2D: Data2D object</span>
<span class="sd">        :return: Data1D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_avg</span><span class="p">(</span><span class="n">data2D</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="SlabX"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.SlabX">[docs]</a><span class="k">class</span> <span class="nc">SlabX</span><span class="p">(</span><span class="n">_Slab</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute average I(Qx) for a region of interest</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute average I(Qx) for a region of interest</span>
<span class="sd">        :param data2D: Data2D object</span>
<span class="sd">        :return: Data1D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_avg</span><span class="p">(</span><span class="n">data2D</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Boxsum"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.Boxsum">[docs]</a><span class="k">class</span> <span class="nc">Boxsum</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the sum of counts in a 2D region of interest.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y_max</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="c"># Minimum Qx value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="n">x_min</span>
        <span class="c"># Maximum Qx value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="n">x_max</span>
        <span class="c"># Minimum Qy value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="n">y_min</span>
        <span class="c"># Maximum Qy value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">y_max</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the sum in the region of interest</span>

<span class="sd">        :param data2D: Data2D object</span>
<span class="sd">        :return: number of counts, error on number of counts,</span>
<span class="sd">            number of points summed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">err_y</span><span class="p">,</span> <span class="n">y_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum</span><span class="p">(</span><span class="n">data2D</span><span class="p">)</span>

        <span class="c"># Average the sums</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">y_counts</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">y</span>
        <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">y_counts</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err_y</span><span class="p">)</span>

        <span class="c"># Added y_counts to return, SMK &amp; PDB, 04/03/2013</span>
        <span class="k">return</span> <span class="n">counts</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">y_counts</span>

    <span class="k">def</span> <span class="nf">_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the sum in the region of interest</span>

<span class="sd">        :param data2D: Data2D object</span>
<span class="sd">        :return: number of counts,</span>
<span class="sd">            error on number of counts, number of entries summed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">detector</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Circular averaging: invalid number &quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s">&quot;of detectors: </span><span class="si">%g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">detector</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="n">msg</span>
        <span class="c"># Get data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">err_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">err_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">qx_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qx_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">qy_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qy_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>

        <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">err_y</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">y_counts</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c"># Average pixelsize in q space</span>
        <span class="k">for</span> <span class="n">npts</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="c"># default frac</span>
            <span class="n">frac_x</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">frac_y</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c"># get min and max at each points</span>
            <span class="n">qx</span> <span class="o">=</span> <span class="n">qx_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
            <span class="n">qy</span> <span class="o">=</span> <span class="n">qy_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>

            <span class="c"># get the ROI</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">&lt;=</span> <span class="n">qx</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">&gt;</span> <span class="n">qx</span><span class="p">:</span>
                <span class="n">frac_x</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">&lt;=</span> <span class="n">qy</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">&gt;</span> <span class="n">qy</span><span class="p">:</span>
                <span class="n">frac_y</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c">#Find the fraction along each directions</span>
            <span class="n">frac</span> <span class="o">=</span> <span class="n">frac_x</span> <span class="o">*</span> <span class="n">frac_y</span>
            <span class="k">if</span> <span class="n">frac</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">err_data</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
                <span class="n">err_y</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err_y</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npts</span><span class="p">]</span>
            <span class="n">y_counts</span> <span class="o">+=</span> <span class="n">frac</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">err_y</span><span class="p">,</span> <span class="n">y_counts</span>

</div>
<div class="viewcode-block" id="Boxavg"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.Boxavg">[docs]</a><span class="k">class</span> <span class="nc">Boxavg</span><span class="p">(</span><span class="n">Boxsum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform the average of counts in a 2D region of interest.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y_max</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Boxavg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">x_min</span><span class="o">=</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="n">x_max</span><span class="p">,</span>
                                     <span class="n">y_min</span><span class="o">=</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="o">=</span><span class="n">y_max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the sum in the region of interest</span>

<span class="sd">        :param data2D: Data2D object</span>
<span class="sd">        :return: average counts, error on average counts</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">err_y</span><span class="p">,</span> <span class="n">y_counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sum</span><span class="p">(</span><span class="n">data2D</span><span class="p">)</span>

        <span class="c"># Average the sums</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">y_counts</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">y</span> <span class="o">/</span> <span class="n">y_counts</span>
        <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">y_counts</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">y_counts</span>

        <span class="k">return</span> <span class="n">counts</span><span class="p">,</span> <span class="n">error</span>

</div>
<div class="viewcode-block" id="get_pixel_fraction_square"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.get_pixel_fraction_square">[docs]</a><span class="k">def</span> <span class="nf">get_pixel_fraction_square</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the fraction of the length</span>
<span class="sd">    from xmin to x.::</span>

<span class="sd">           A            B</span>
<span class="sd">       +-----------+---------+</span>
<span class="sd">       xmin        x         xmax</span>

<span class="sd">    :param x: x-value</span>
<span class="sd">    :param xmin: minimum x for the length considered</span>
<span class="sd">    :param xmax: minimum x for the length considered</span>
<span class="sd">    :return: (x-xmin)/(xmax-xmin) when xmin &lt; x &lt; xmax</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xmin</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">xmin</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">xmax</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span>

</div>
<div class="viewcode-block" id="CircularAverage"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.CircularAverage">[docs]</a><span class="k">class</span> <span class="nc">CircularAverage</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform circular averaging on 2D data</span>

<span class="sd">    The data returned is the distribution of counts</span>
<span class="sd">    as a function of Q</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">bin_width</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">):</span>
        <span class="c"># Minimum radius included in the average [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span> <span class="o">=</span> <span class="n">r_min</span>
        <span class="c"># Maximum radius included in the average [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_max</span> <span class="o">=</span> <span class="n">r_max</span>
        <span class="c"># Bin width (step size) [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span> <span class="o">=</span> <span class="n">bin_width</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">,</span> <span class="n">ismask</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform circular averaging on the data</span>

<span class="sd">        :param data2D: Data2D object</span>
<span class="sd">        :return: Data1D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Get data W/ finite values</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">q_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">err_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">err_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">mask_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>

        <span class="n">dq_data</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Get the dq for resolution averaging</span>
        <span class="k">if</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># The pinholes and det. pix contribution present</span>
            <span class="c"># in both direction of the 2D which must be subtracted when</span>
            <span class="c"># converting to 1D: dq_overlap should calculated ideally at</span>
            <span class="c"># q = 0. Note This method works on only pinhole geometry.</span>
            <span class="c"># Extrapolate dqx(r) and dqy(phi) at q = 0, and take an average.</span>
            <span class="n">z_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">)</span>
            <span class="n">z_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">)</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">[</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">z_max</span><span class="p">]]</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">[</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">z_min</span><span class="p">]]</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">[</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">z_max</span><span class="p">]]</span>
            <span class="n">y_min</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">[</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">z_min</span><span class="p">]]</span>
            <span class="c"># Find qdx at q = 0</span>
            <span class="n">dq_overlap_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_min</span> <span class="o">*</span> <span class="n">z_max</span> <span class="o">-</span> <span class="n">x_max</span> <span class="o">*</span> <span class="n">z_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z_max</span> <span class="o">-</span> <span class="n">z_min</span><span class="p">)</span>
            <span class="c"># when extrapolation goes wrong</span>
            <span class="k">if</span> <span class="n">dq_overlap_x</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">):</span>
                <span class="n">dq_overlap_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">)</span>
            <span class="n">dq_overlap_x</span> <span class="o">*=</span> <span class="n">dq_overlap_x</span>
            <span class="c"># Find qdx at q = 0</span>
            <span class="n">dq_overlap_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_min</span> <span class="o">*</span> <span class="n">z_max</span> <span class="o">-</span> <span class="n">y_max</span> <span class="o">*</span> <span class="n">z_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z_max</span> <span class="o">-</span> <span class="n">z_min</span><span class="p">)</span>
            <span class="c"># when extrapolation goes wrong</span>
            <span class="k">if</span> <span class="n">dq_overlap_y</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">):</span>
                <span class="n">dq_overlap_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">)</span>
            <span class="c"># get dq at q=0.</span>
            <span class="n">dq_overlap_y</span> <span class="o">*=</span> <span class="n">dq_overlap_y</span>

            <span class="n">dq_overlap</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dq_overlap_x</span> <span class="o">+</span> <span class="n">dq_overlap_y</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="c"># Final protection of dq</span>
            <span class="k">if</span> <span class="n">dq_overlap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dq_overlap</span> <span class="o">=</span> <span class="n">y_min</span>
            <span class="n">dqx_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
            <span class="n">dqy_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span> <span class="o">-</span> <span class="n">dq_overlap</span>
            <span class="c"># def; dqx_data = dq_r dqy_data = dq_phi</span>
            <span class="c"># Convert dq 2D to 1D here</span>
            <span class="n">dqx</span> <span class="o">=</span> <span class="n">dqx_data</span> <span class="o">*</span> <span class="n">dqx_data</span>
            <span class="n">dqy</span> <span class="o">=</span> <span class="n">dqy_data</span> <span class="o">*</span> <span class="n">dqy_data</span>
            <span class="n">dq_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dqx</span><span class="p">,</span> <span class="n">dqy</span><span class="p">)</span>
            <span class="n">dq_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dq_data</span><span class="p">)</span>

        <span class="c">#q_data_max = numpy.max(q_data)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">)</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Circular averaging: invalid q_data: </span><span class="si">%g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="n">msg</span>

        <span class="c"># Build array of Q intervals</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">r_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span><span class="p">))</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">err_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">err_x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">y_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">npt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>

            <span class="k">if</span> <span class="n">ismask</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mask_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">frac</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c"># q-value at the pixel (j,i)</span>
            <span class="n">q_value</span> <span class="o">=</span> <span class="n">q_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span>
            <span class="n">data_n</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span>

            <span class="c">## No need to calculate the frac when all data are within range</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_max</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;Limit Error: min &gt; max&quot;</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span> <span class="o">&lt;=</span> <span class="n">q_value</span> <span class="ow">and</span> <span class="n">q_value</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_max</span><span class="p">:</span>
                <span class="n">frac</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">frac</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">i_q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">q_value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_width</span><span class="p">))</span>

            <span class="c"># Take care of the edge case at phi = 2pi.</span>
            <span class="k">if</span> <span class="n">i_q</span> <span class="o">==</span> <span class="n">nbins</span><span class="p">:</span>
                <span class="n">i_q</span> <span class="o">=</span> <span class="n">nbins</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">y</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">data_n</span>
            <span class="c"># Take dqs from data to get the q_average</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">q_value</span>
            <span class="k">if</span> <span class="n">err_data</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data_n</span> <span class="o">=</span> <span class="o">-</span><span class="n">data_n</span>
                <span class="n">err_y</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">data_n</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err_y</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dq_data</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># To be consistent with dq calculation in 1d reduction,</span>
                <span class="c"># we need just the averages (not quadratures) because</span>
                <span class="c"># it should not depend on the number of the q points</span>
                <span class="c"># in the qr bins.</span>
                <span class="n">err_x</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">dq_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">err_x</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">y_counts</span><span class="p">[</span><span class="n">i_q</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span>

        <span class="c"># Average the sums</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbins</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">err_y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">err_y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">err_y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">err_y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err_y</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="c">#if err_x != None:</span>
            <span class="c">#    err_x[n] = math.sqrt(err_x[n])</span>

        <span class="n">err_y</span> <span class="o">=</span> <span class="n">err_y</span> <span class="o">/</span> <span class="n">y_counts</span>
        <span class="n">err_y</span><span class="p">[</span><span class="n">err_y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">err_y</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">y_counts</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y_counts</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">err_x</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">d_x</span> <span class="o">=</span> <span class="n">err_x</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">y_counts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_x</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Average Error: No points inside ROI to average...&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">msg</span>

        <span class="k">return</span> <span class="n">Data1D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dy</span><span class="o">=</span><span class="n">err_y</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dx</span><span class="o">=</span><span class="n">d_x</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Ring"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.Ring">[docs]</a><span class="k">class</span> <span class="nc">Ring</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a ring on a 2D data set.</span>
<span class="sd">    The ring is defined by r_min, r_max, and</span>
<span class="sd">    the position of the center of the ring.</span>

<span class="sd">    The data returned is the distribution of counts</span>
<span class="sd">    around the ring as a function of phi.</span>

<span class="sd">    Phi_min and phi_max should be defined between 0 and 2*pi</span>
<span class="sd">    in anti-clockwise starting from the x- axis on the left-hand side</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#Todo: remove center.</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">36</span><span class="p">):</span>
        <span class="c"># Minimum radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span> <span class="o">=</span> <span class="n">r_min</span>
        <span class="c"># Maximum radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_max</span> <span class="o">=</span> <span class="n">r_max</span>
        <span class="c"># Center of the ring in x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_x</span> <span class="o">=</span> <span class="n">center_x</span>
        <span class="c"># Center of the ring in y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_y</span> <span class="o">=</span> <span class="n">center_y</span>
        <span class="c"># Number of angular bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span> <span class="o">=</span> <span class="n">nbins</span>


    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the ring to the data set.</span>
<span class="sd">        Returns the angular distribution for a given q range</span>

<span class="sd">        :param data2D: Data2D object</span>

<span class="sd">        :return: Data1D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data2D</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;Data2D&quot;</span><span class="p">,</span> <span class="s">&quot;plottable_2D&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="s">&quot;Ring averaging only take plottable_2D objects&quot;</span>

        <span class="n">Pi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

        <span class="c"># Get data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">q_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">err_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">err_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">qx_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qx_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">qy_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qy_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>

        <span class="c"># Set space for 1d outputs</span>
        <span class="n">phi_bins</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span><span class="p">)</span>
        <span class="n">phi_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span><span class="p">)</span>
        <span class="n">phi_values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span><span class="p">)</span>
        <span class="n">phi_err</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span><span class="p">)</span>

        <span class="c"># Shift to apply to calculated phi values in order</span>
        <span class="c"># to center first bin at zero</span>
        <span class="n">phi_shift</span> <span class="o">=</span> <span class="n">Pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span>

        <span class="k">for</span> <span class="n">npt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="n">frac</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c"># q-value at the point (npt)</span>
            <span class="n">q_value</span> <span class="o">=</span> <span class="n">q_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span>
            <span class="n">data_n</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span>

            <span class="c"># phi-value at the point (npt)</span>
            <span class="n">phi_value</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">qy_data</span><span class="p">[</span><span class="n">npt</span><span class="p">],</span> <span class="n">qx_data</span><span class="p">[</span><span class="n">npt</span><span class="p">])</span> <span class="o">+</span> <span class="n">Pi</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span> <span class="o">&lt;=</span> <span class="n">q_value</span> <span class="ow">and</span> <span class="n">q_value</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_max</span><span class="p">:</span>
                <span class="n">frac</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">frac</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c"># binning</span>
            <span class="n">i_phi</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span><span class="p">)</span> <span class="o">*</span> \
                                   <span class="p">(</span><span class="n">phi_value</span> <span class="o">+</span> <span class="n">phi_shift</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Pi</span><span class="p">)))</span>

            <span class="c"># Take care of the edge case at phi = 2pi.</span>
            <span class="k">if</span> <span class="n">i_phi</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span><span class="p">:</span>
                <span class="n">i_phi</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">phi_bins</span><span class="p">[</span><span class="n">i_phi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">err_data</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data_n</span> <span class="o">=</span> <span class="o">-</span><span class="n">data_n</span>
                <span class="n">phi_err</span><span class="p">[</span><span class="n">i_phi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">data_n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phi_err</span><span class="p">[</span><span class="n">i_phi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">npt</span><span class="p">]</span>
            <span class="n">phi_counts</span><span class="p">[</span><span class="n">i_phi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span><span class="p">):</span>
            <span class="n">phi_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">phi_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">phi_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">phi_err</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">phi_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">phi_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins_phi</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">phi_bins</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Average Error: No points inside ROI to average...&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">msg</span>
        <span class="c">#elif len(phi_bins[idx])!= self.nbins_phi:</span>
        <span class="c">#    print &quot;resulted&quot;,self.nbins_phi- len(phi_bins[idx])</span>
        <span class="c">#,&quot;empty bin(s) due to tight binning...&quot;</span>
        <span class="k">return</span> <span class="n">Data1D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">phi_values</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">phi_bins</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dy</span><span class="o">=</span><span class="n">phi_err</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="get_pixel_fraction"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.get_pixel_fraction">[docs]</a><span class="k">def</span> <span class="nf">get_pixel_fraction</span><span class="p">(</span><span class="n">qmax</span><span class="p">,</span> <span class="n">q_00</span><span class="p">,</span> <span class="n">q_01</span><span class="p">,</span> <span class="n">q_10</span><span class="p">,</span> <span class="n">q_11</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the fraction of the pixel defined by</span>
<span class="sd">    the four corners (q_00, q_01, q_10, q_11) that</span>
<span class="sd">    has q &lt; qmax.::</span>

<span class="sd">                q_01                q_11</span>
<span class="sd">        y=1         +--------------+</span>
<span class="sd">                    |              |</span>
<span class="sd">                    |              |</span>
<span class="sd">                    |              |</span>
<span class="sd">        y=0         +--------------+</span>
<span class="sd">                q_00                q_10</span>

<span class="sd">                    x=0            x=1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># y side for x = minx</span>
    <span class="n">x_0</span> <span class="o">=</span> <span class="n">get_intercept</span><span class="p">(</span><span class="n">qmax</span><span class="p">,</span> <span class="n">q_00</span><span class="p">,</span> <span class="n">q_01</span><span class="p">)</span>
    <span class="c"># y side for x = maxx</span>
    <span class="n">x_1</span> <span class="o">=</span> <span class="n">get_intercept</span><span class="p">(</span><span class="n">qmax</span><span class="p">,</span> <span class="n">q_10</span><span class="p">,</span> <span class="n">q_11</span><span class="p">)</span>

    <span class="c"># x side for y = miny</span>
    <span class="n">y_0</span> <span class="o">=</span> <span class="n">get_intercept</span><span class="p">(</span><span class="n">qmax</span><span class="p">,</span> <span class="n">q_00</span><span class="p">,</span> <span class="n">q_10</span><span class="p">)</span>
    <span class="c"># x side for y = maxy</span>
    <span class="n">y_1</span> <span class="o">=</span> <span class="n">get_intercept</span><span class="p">(</span><span class="n">qmax</span><span class="p">,</span> <span class="n">q_01</span><span class="p">,</span> <span class="n">q_11</span><span class="p">)</span>

    <span class="c"># surface fraction for a 1x1 pixel</span>
    <span class="n">frac_max</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">x_0</span> <span class="ow">and</span> <span class="n">x_1</span><span class="p">:</span>
        <span class="n">frac_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_0</span> <span class="o">+</span> <span class="n">x_1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">elif</span> <span class="n">y_0</span> <span class="ow">and</span> <span class="n">y_1</span><span class="p">:</span>
        <span class="n">frac_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_0</span> <span class="o">+</span> <span class="n">y_1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">elif</span> <span class="n">x_0</span> <span class="ow">and</span> <span class="n">y_0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q_00</span> <span class="o">&lt;</span> <span class="n">q_10</span><span class="p">:</span>
            <span class="n">frac_max</span> <span class="o">=</span> <span class="n">x_0</span> <span class="o">*</span> <span class="n">y_0</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frac_max</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">x_0</span> <span class="o">*</span> <span class="n">y_0</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">elif</span> <span class="n">x_0</span> <span class="ow">and</span> <span class="n">y_1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q_00</span> <span class="o">&lt;</span> <span class="n">q_10</span><span class="p">:</span>
            <span class="n">frac_max</span> <span class="o">=</span> <span class="n">x_0</span> <span class="o">*</span> <span class="n">y_1</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frac_max</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">x_0</span> <span class="o">*</span> <span class="n">y_1</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">elif</span> <span class="n">x_1</span> <span class="ow">and</span> <span class="n">y_0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q_00</span> <span class="o">&gt;</span> <span class="n">q_10</span><span class="p">:</span>
            <span class="n">frac_max</span> <span class="o">=</span> <span class="n">x_1</span> <span class="o">*</span> <span class="n">y_0</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frac_max</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">x_1</span> <span class="o">*</span> <span class="n">y_0</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">elif</span> <span class="n">x_1</span> <span class="ow">and</span> <span class="n">y_1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q_00</span> <span class="o">&lt;</span> <span class="n">q_10</span><span class="p">:</span>
            <span class="n">frac_max</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x_1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">y_1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frac_max</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">x_1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">y_1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="c"># If we make it here, there is no intercept between</span>
    <span class="c"># this pixel and the constant-q ring. We only need</span>
    <span class="c"># to know if we have to include it or exclude it.</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">q_00</span> <span class="o">+</span> <span class="n">q_01</span> <span class="o">+</span> <span class="n">q_10</span> <span class="o">+</span> <span class="n">q_11</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span> <span class="o">&lt;</span> <span class="n">qmax</span><span class="p">:</span>
        <span class="n">frac_max</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">frac_max</span>

</div>
<div class="viewcode-block" id="get_intercept"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.get_intercept">[docs]</a><span class="k">def</span> <span class="nf">get_intercept</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_0</span><span class="p">,</span> <span class="n">q_1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the fraction of the side at which the</span>
<span class="sd">    q-value intercept the pixel, None otherwise.</span>
<span class="sd">    The values returned is the fraction ON THE SIDE</span>
<span class="sd">    OF THE LOWEST Q. ::</span>

<span class="sd">            A           B</span>
<span class="sd">        +-----------+--------+    &lt;--- pixel size</span>
<span class="sd">        0                    1</span>
<span class="sd">        Q_0 -------- Q ----- Q_1   &lt;--- equivalent Q range</span>
<span class="sd">        if Q_1 &gt; Q_0, A is returned</span>
<span class="sd">        if Q_1 &lt; Q_0, B is returned</span>
<span class="sd">        if Q is outside the range of [Q_0, Q_1], None is returned</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">q_1</span> <span class="o">&gt;</span> <span class="n">q_0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="n">q_0</span> <span class="ow">and</span> <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">q_1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">q_0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">q_1</span> <span class="o">-</span> <span class="n">q_0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="n">q_1</span> <span class="ow">and</span> <span class="n">q</span> <span class="o">&lt;=</span> <span class="n">q_0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">q_1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">q_0</span> <span class="o">-</span> <span class="n">q_1</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="k">class</span> <span class="nc">_Sector</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a sector region on a 2D data set.</span>
<span class="sd">    The sector is defined by r_min, r_max, phi_min, phi_max,</span>
<span class="sd">    and the position of the center of the ring</span>
<span class="sd">    where phi_min and phi_max are defined by the right</span>
<span class="sd">    and left lines wrt central line</span>
<span class="sd">    and phi_max could be less than phi_min.</span>

<span class="sd">    Phi is defined between 0 and 2*pi in anti-clockwise</span>
<span class="sd">    starting from the x- axis on the left-hand side</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_min</span><span class="p">,</span> <span class="n">r_max</span><span class="p">,</span> <span class="n">phi_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi_max</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span> <span class="o">=</span> <span class="n">r_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_max</span> <span class="o">=</span> <span class="n">r_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_min</span> <span class="o">=</span> <span class="n">phi_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_max</span> <span class="o">=</span> <span class="n">phi_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">=</span> <span class="n">nbins</span>

    <span class="k">def</span> <span class="nf">_agv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">,</span> <span class="n">run</span><span class="o">=</span><span class="s">&#39;phi&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform sector averaging.</span>

<span class="sd">        :param data2D: Data2D object</span>
<span class="sd">        :param run:  define the varying parameter (&#39;phi&#39; , &#39;q&#39; , or &#39;q2&#39;)</span>

<span class="sd">        :return: Data1D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data2D</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;Data2D&quot;</span><span class="p">,</span> <span class="s">&quot;plottable_2D&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="s">&quot;Ring averaging only take plottable_2D objects&quot;</span>
        <span class="n">Pi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>

        <span class="c"># Get the all data &amp; info</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">q_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">err_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">err_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">qx_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qx_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">qy_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qy_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">dq_data</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Get the dq for resolution averaging</span>
        <span class="k">if</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span> <span class="o">!=</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># The pinholes and det. pix contribution present</span>
            <span class="c"># in both direction of the 2D which must be subtracted when</span>
            <span class="c"># converting to 1D: dq_overlap should calculated ideally at</span>
            <span class="c"># q = 0.</span>
            <span class="c"># Extrapolate dqy(perp) at q = 0</span>
            <span class="n">z_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">)</span>
            <span class="n">z_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">)</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">[</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">z_max</span><span class="p">]]</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">[</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">z_min</span><span class="p">]]</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">[</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">z_max</span><span class="p">]]</span>
            <span class="n">y_min</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">[</span><span class="n">data2D</span><span class="o">.</span><span class="n">q_data</span><span class="p">[</span><span class="n">z_min</span><span class="p">]]</span>
            <span class="c"># Find qdx at q = 0</span>
            <span class="n">dq_overlap_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_min</span> <span class="o">*</span> <span class="n">z_max</span> <span class="o">-</span> <span class="n">x_max</span> <span class="o">*</span> <span class="n">z_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z_max</span> <span class="o">-</span> <span class="n">z_min</span><span class="p">)</span>
            <span class="c"># when extrapolation goes wrong</span>
            <span class="k">if</span> <span class="n">dq_overlap_x</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">):</span>
                <span class="n">dq_overlap_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">)</span>
            <span class="n">dq_overlap_x</span> <span class="o">*=</span> <span class="n">dq_overlap_x</span>
            <span class="c"># Find qdx at q = 0</span>
            <span class="n">dq_overlap_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_min</span> <span class="o">*</span> <span class="n">z_max</span> <span class="o">-</span> <span class="n">y_max</span> <span class="o">*</span> <span class="n">z_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z_max</span> <span class="o">-</span> <span class="n">z_min</span><span class="p">)</span>
            <span class="c"># when extrapolation goes wrong</span>
            <span class="k">if</span> <span class="n">dq_overlap_y</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">):</span>
                <span class="n">dq_overlap_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">)</span>
            <span class="c"># get dq at q=0.</span>
            <span class="n">dq_overlap_y</span> <span class="o">*=</span> <span class="n">dq_overlap_y</span>

            <span class="n">dq_overlap</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dq_overlap_x</span> <span class="o">+</span> <span class="n">dq_overlap_y</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dq_overlap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dq_overlap</span> <span class="o">=</span> <span class="n">y_min</span>
            <span class="n">dqx_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqx_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span>
            <span class="n">dqy_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">dqy_data</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data2D</span><span class="o">.</span><span class="n">data</span><span class="p">)]</span> <span class="o">-</span> <span class="n">dq_overlap</span>
            <span class="c"># def; dqx_data = dq_r dqy_data = dq_phi</span>
            <span class="c"># Convert dq 2D to 1D here</span>
            <span class="n">dqx</span> <span class="o">=</span> <span class="n">dqx_data</span> <span class="o">*</span> <span class="n">dqx_data</span>
            <span class="n">dqy</span> <span class="o">=</span> <span class="n">dqy_data</span> <span class="o">*</span> <span class="n">dqy_data</span>
            <span class="n">dq_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dqx</span><span class="p">,</span> <span class="n">dqy</span><span class="p">)</span>
            <span class="n">dq_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dq_data</span><span class="p">)</span>

        <span class="c">#set space for 1d outputs</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">y_err</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">x_err</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">y_counts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span>

        <span class="c"># Get the min and max into the region: 0 &lt;= phi &lt; 2Pi</span>
        <span class="n">phi_min</span> <span class="o">=</span> <span class="n">flip_phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_min</span><span class="p">)</span>
        <span class="n">phi_max</span> <span class="o">=</span> <span class="n">flip_phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_max</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="n">frac</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c"># q-value at the pixel (j,i)</span>
            <span class="n">q_value</span> <span class="o">=</span> <span class="n">q_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">data_n</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

            <span class="c"># Is pixel within range?</span>
            <span class="n">is_in</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c"># phi-value of the pixel (j,i)</span>
            <span class="n">phi_value</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">qy_data</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">qx_data</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">+</span> <span class="n">Pi</span>

            <span class="c">## No need to calculate the frac when all data are within range</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span> <span class="o">&lt;=</span> <span class="n">q_value</span> <span class="ow">and</span> <span class="n">q_value</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_max</span><span class="p">:</span>
                <span class="n">frac</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">frac</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c">#In case of two ROIs (symmetric major and minor regions)(for &#39;q2&#39;)</span>
            <span class="k">if</span> <span class="n">run</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;q2&#39;</span><span class="p">:</span>
                <span class="c">## For minor sector wing</span>
                <span class="c"># Calculate the minor wing phis</span>
                <span class="n">phi_min_minor</span> <span class="o">=</span> <span class="n">flip_phi</span><span class="p">(</span><span class="n">phi_min</span> <span class="o">-</span> <span class="n">Pi</span><span class="p">)</span>
                <span class="n">phi_max_minor</span> <span class="o">=</span> <span class="n">flip_phi</span><span class="p">(</span><span class="n">phi_max</span> <span class="o">-</span> <span class="n">Pi</span><span class="p">)</span>
                <span class="c"># Check if phis of the minor ring is within 0 to 2pi</span>
                <span class="k">if</span> <span class="n">phi_min_minor</span> <span class="o">&gt;</span> <span class="n">phi_max_minor</span><span class="p">:</span>
                    <span class="n">is_in</span> <span class="o">=</span> <span class="p">(</span><span class="n">phi_value</span> <span class="o">&gt;</span> <span class="n">phi_min_minor</span> <span class="ow">or</span> \
                              <span class="n">phi_value</span> <span class="o">&lt;</span> <span class="n">phi_max_minor</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">is_in</span> <span class="o">=</span> <span class="p">(</span><span class="n">phi_value</span> <span class="o">&gt;</span> <span class="n">phi_min_minor</span> <span class="ow">and</span> \
                              <span class="n">phi_value</span> <span class="o">&lt;</span> <span class="n">phi_max_minor</span><span class="p">)</span>

            <span class="c">#For all cases(i.e.,for &#39;q&#39;, &#39;q2&#39;, and &#39;phi&#39;)</span>
            <span class="c">#Find pixels within ROI</span>
            <span class="k">if</span> <span class="n">phi_min</span> <span class="o">&gt;</span> <span class="n">phi_max</span><span class="p">:</span>
                <span class="n">is_in</span> <span class="o">=</span> <span class="n">is_in</span> <span class="ow">or</span> <span class="p">(</span><span class="n">phi_value</span> <span class="o">&gt;</span> <span class="n">phi_min</span> <span class="ow">or</span> \
                                   <span class="n">phi_value</span> <span class="o">&lt;</span> <span class="n">phi_max</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_in</span> <span class="o">=</span> <span class="n">is_in</span> <span class="ow">or</span> <span class="p">(</span><span class="n">phi_value</span> <span class="o">&gt;=</span> <span class="n">phi_min</span>  <span class="ow">and</span> \
                                    <span class="n">phi_value</span> <span class="o">&lt;</span> <span class="n">phi_max</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_in</span><span class="p">:</span>
                <span class="n">frac</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">frac</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c"># Check which type of averaging we need</span>
            <span class="k">if</span> <span class="n">run</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;phi&#39;</span><span class="p">:</span>
                <span class="n">temp_x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">phi_value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_min</span><span class="p">)</span>
                <span class="n">temp_y</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_min</span><span class="p">)</span>
                <span class="n">i_bin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">temp_x</span> <span class="o">/</span> <span class="n">temp_y</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">temp_x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">q_value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span><span class="p">)</span>
                <span class="n">temp_y</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span><span class="p">)</span>
                <span class="n">i_bin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">temp_x</span> <span class="o">/</span> <span class="n">temp_y</span><span class="p">))</span>

            <span class="c"># Take care of the edge case at phi = 2pi.</span>
            <span class="k">if</span> <span class="n">i_bin</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">:</span>
                <span class="n">i_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c">## Get the total y</span>
            <span class="n">y</span><span class="p">[</span><span class="n">i_bin</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">data_n</span>
            <span class="n">x</span><span class="p">[</span><span class="n">i_bin</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">q_value</span>
            <span class="k">if</span> <span class="n">err_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">err_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data_n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data_n</span> <span class="o">=</span> <span class="o">-</span><span class="n">data_n</span>
                <span class="n">y_err</span><span class="p">[</span><span class="n">i_bin</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">data_n</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_err</span><span class="p">[</span><span class="n">i_bin</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">err_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">dq_data</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># To be consistent with dq calculation in 1d reduction,</span>
                <span class="c"># we need just the averages (not quadratures) because</span>
                <span class="c"># it should not depend on the number of the q points</span>
                <span class="c"># in the qr bins.</span>
                <span class="n">x_err</span><span class="p">[</span><span class="n">i_bin</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span> <span class="o">*</span> <span class="n">dq_data</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_err</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">y_counts</span><span class="p">[</span><span class="n">i_bin</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frac</span>

        <span class="c"># Organize the results</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbins</span><span class="p">):</span>
            <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">y_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">y_err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_err</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">y_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c"># The type of averaging: phi,q2, or q</span>
            <span class="c"># Calculate x[i]should be at the center of the bin</span>
            <span class="k">if</span> <span class="n">run</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;phi&#39;</span><span class="p">:</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_min</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbins</span> <span class="o">*</span> \
                    <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_min</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># We take the center of ring area, not radius.</span>
                <span class="c"># This is more accurate than taking the radial center of ring.</span>
                <span class="c">#delta_r = (self.r_max - self.r_min) / self.nbins</span>
                <span class="c">#r_inner = self.r_min + delta_r * i</span>
                <span class="c">#r_outer = r_inner + delta_r</span>
                <span class="c">#x[i] = math.sqrt((r_inner * r_inner + r_outer * r_outer) / 2)</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">y_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y_err</span><span class="p">[</span><span class="n">y_err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">y_err</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_err</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">x_err</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">d_x</span> <span class="o">=</span> <span class="n">x_err</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">y_counts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d_x</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Average Error: No points inside sector of ROI to average...&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">msg</span>
        <span class="c">#elif len(y[idx])!= self.nbins:</span>
        <span class="c">#    print &quot;resulted&quot;,self.nbins- len(y[idx]),</span>
        <span class="c">#&quot;empty bin(s) due to tight binning...&quot;</span>
        <span class="k">return</span> <span class="n">Data1D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dy</span><span class="o">=</span><span class="n">y_err</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dx</span><span class="o">=</span><span class="n">d_x</span><span class="p">)</span>


<div class="viewcode-block" id="SectorPhi"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.SectorPhi">[docs]</a><span class="k">class</span> <span class="nc">SectorPhi</span><span class="p">(</span><span class="n">_Sector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sector average as a function of phi.</span>
<span class="sd">    I(phi) is return and the data is averaged over Q.</span>

<span class="sd">    A sector is defined by r_min, r_max, phi_min, phi_max.</span>
<span class="sd">    The number of bin in phi also has to be defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform sector average and return I(phi).</span>

<span class="sd">        :param data2D: Data2D object</span>
<span class="sd">        :return: Data1D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agv</span><span class="p">(</span><span class="n">data2D</span><span class="p">,</span> <span class="s">&#39;phi&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="SectorQ"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.SectorQ">[docs]</a><span class="k">class</span> <span class="nc">SectorQ</span><span class="p">(</span><span class="n">_Sector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sector average as a function of Q for both symatric wings.</span>
<span class="sd">    I(Q) is return and the data is averaged over phi.</span>

<span class="sd">    A sector is defined by r_min, r_max, phi_min, phi_max.</span>
<span class="sd">    r_min, r_max, phi_min, phi_max &gt;0.</span>
<span class="sd">    The number of bin in Q also has to be defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform sector average and return I(Q).</span>

<span class="sd">        :param data2D: Data2D object</span>

<span class="sd">        :return: Data1D object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agv</span><span class="p">(</span><span class="n">data2D</span><span class="p">,</span> <span class="s">&#39;q2&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Ringcut"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.Ringcut">[docs]</a><span class="k">class</span> <span class="nc">Ringcut</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a ring on a 2D data set.</span>
<span class="sd">    The ring is defined by r_min, r_max, and</span>
<span class="sd">    the position of the center of the ring.</span>

<span class="sd">    The data returned is the region inside the ring</span>

<span class="sd">    Phi_min and phi_max should be defined between 0 and 2*pi</span>
<span class="sd">    in anti-clockwise starting from the x- axis on the left-hand side</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">r_max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c"># Minimum radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_min</span> <span class="o">=</span> <span class="n">r_min</span>
        <span class="c"># Maximum radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_max</span> <span class="o">=</span> <span class="n">r_max</span>
        <span class="c"># Center of the ring in x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_x</span> <span class="o">=</span> <span class="n">center_x</span>
        <span class="c"># Center of the ring in y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_y</span> <span class="o">=</span> <span class="n">center_y</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the ring to the data set.</span>
<span class="sd">        Returns the angular distribution for a given q range</span>

<span class="sd">        :param data2D: Data2D object</span>

<span class="sd">        :return: index array in the range</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data2D</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;Data2D&quot;</span><span class="p">,</span> <span class="s">&quot;plottable_2D&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="s">&quot;Ring cut only take plottable_2D objects&quot;</span>

        <span class="c"># Get data</span>
        <span class="n">qx_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qx_data</span>
        <span class="n">qy_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qy_data</span>
        <span class="n">q_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qx_data</span> <span class="o">*</span> <span class="n">qx_data</span> <span class="o">+</span> <span class="n">qy_data</span> <span class="o">*</span> <span class="n">qy_data</span><span class="p">)</span>

        <span class="c"># check whether or not the data point is inside ROI</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r_min</span> <span class="o">&lt;=</span> <span class="n">q_data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r_max</span> <span class="o">&gt;=</span> <span class="n">q_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

</div>
<div class="viewcode-block" id="Boxcut"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.Boxcut">[docs]</a><span class="k">class</span> <span class="nc">Boxcut</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a rectangular 2D region of interest.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y_max</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="c"># Minimum Qx value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="n">x_min</span>
        <span class="c"># Maximum Qx value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="n">x_max</span>
        <span class="c"># Minimum Qy value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="n">y_min</span>
        <span class="c"># Maximum Qy value [A-1]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">y_max</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       Find a rectangular 2D region of interest.</span>

<span class="sd">       :param data2D: Data2D object</span>
<span class="sd">       :return: mask, 1d array (len = len(data))</span>
<span class="sd">           with Trues where the data points are inside ROI, otherwise False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">data2D</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a rectangular 2D region of interest.</span>

<span class="sd">        :param data2D: Data2D object</span>

<span class="sd">        :return: out, 1d array (length = len(data))</span>
<span class="sd">           with Trues where the data points are inside ROI, otherwise Falses</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data2D</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;Data2D&quot;</span><span class="p">,</span> <span class="s">&quot;plottable_2D&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="s">&quot;Boxcut take only plottable_2D objects&quot;</span>
        <span class="c"># Get qx_ and qy_data</span>
        <span class="n">qx_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qx_data</span>
        <span class="n">qy_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qy_data</span>

        <span class="c"># check whether or not the data point is inside ROI</span>
        <span class="n">outx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">&lt;=</span> <span class="n">qx_data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">&gt;</span> <span class="n">qx_data</span><span class="p">)</span>
        <span class="n">outy</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">&lt;=</span> <span class="n">qy_data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">&gt;</span> <span class="n">qy_data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">outx</span> <span class="o">&amp;</span> <span class="n">outy</span>

</div>
<div class="viewcode-block" id="Sectorcut"><a class="viewcode-back" href="../../../dev/api/sas.dataloader.html#sas.dataloader.manipulations.Sectorcut">[docs]</a><span class="k">class</span> <span class="nc">Sectorcut</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a sector (major + minor) region on a 2D data set.</span>
<span class="sd">    The sector is defined by phi_min, phi_max,</span>
<span class="sd">    where phi_min and phi_max are defined by the right</span>
<span class="sd">    and left lines wrt central line.</span>

<span class="sd">    Phi_min and phi_max are given in units of radian</span>
<span class="sd">    and (phi_max-phi_min) should not be larger than pi</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">phi_max</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_min</span> <span class="o">=</span> <span class="n">phi_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_max</span> <span class="o">=</span> <span class="n">phi_max</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a rectangular 2D region of interest.</span>

<span class="sd">        :param data2D: Data2D object</span>

<span class="sd">        :return: mask, 1d array (len = len(data))</span>

<span class="sd">        with Trues where the data points are inside ROI, otherwise False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">data2D</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data2D</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a rectangular 2D region of interest.</span>

<span class="sd">        :param data2D: Data2D object</span>

<span class="sd">        :return: out, 1d array (length = len(data))</span>

<span class="sd">        with Trues where the data points are inside ROI, otherwise Falses</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data2D</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;Data2D&quot;</span><span class="p">,</span> <span class="s">&quot;plottable_2D&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="s">&quot;Sectorcut take only plottable_2D objects&quot;</span>
        <span class="n">Pi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="c"># Get data</span>
        <span class="n">qx_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qx_data</span>
        <span class="n">qy_data</span> <span class="o">=</span> <span class="n">data2D</span><span class="o">.</span><span class="n">qy_data</span>

        <span class="c"># get phi from data</span>
        <span class="n">phi_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">qy_data</span><span class="p">,</span> <span class="n">qx_data</span><span class="p">)</span>

        <span class="c"># Get the min and max into the region: -pi &lt;= phi &lt; Pi</span>
        <span class="n">phi_min_major</span> <span class="o">=</span> <span class="n">flip_phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_min</span> <span class="o">+</span> <span class="n">Pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">Pi</span>
        <span class="n">phi_max_major</span> <span class="o">=</span> <span class="n">flip_phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_max</span> <span class="o">+</span> <span class="n">Pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">Pi</span>
        <span class="c"># check for major sector</span>
        <span class="k">if</span> <span class="n">phi_min_major</span> <span class="o">&gt;</span> <span class="n">phi_max_major</span><span class="p">:</span>
            <span class="n">out_major</span> <span class="o">=</span> <span class="p">(</span><span class="n">phi_min_major</span> <span class="o">&lt;=</span> <span class="n">phi_data</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">phi_max_major</span> <span class="o">&gt;</span> <span class="n">phi_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_major</span> <span class="o">=</span> <span class="p">(</span><span class="n">phi_min_major</span> <span class="o">&lt;=</span> <span class="n">phi_data</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">phi_max_major</span> <span class="o">&gt;</span> <span class="n">phi_data</span><span class="p">)</span>

        <span class="c"># minor sector</span>
        <span class="c"># Get the min and max into the region: -pi &lt;= phi &lt; Pi</span>
        <span class="n">phi_min_minor</span> <span class="o">=</span> <span class="n">flip_phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_min</span><span class="p">)</span> <span class="o">-</span> <span class="n">Pi</span>
        <span class="n">phi_max_minor</span> <span class="o">=</span> <span class="n">flip_phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_max</span><span class="p">)</span> <span class="o">-</span> <span class="n">Pi</span>

        <span class="c"># check for minor sector</span>
        <span class="k">if</span> <span class="n">phi_min_minor</span> <span class="o">&gt;</span> <span class="n">phi_max_minor</span><span class="p">:</span>
            <span class="n">out_minor</span> <span class="o">=</span> <span class="p">(</span><span class="n">phi_min_minor</span> <span class="o">&lt;=</span> <span class="n">phi_data</span><span class="p">)</span> <span class="o">+</span> \
                            <span class="p">(</span><span class="n">phi_max_minor</span> <span class="o">&gt;=</span> <span class="n">phi_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_minor</span> <span class="o">=</span> <span class="p">(</span><span class="n">phi_min_minor</span> <span class="o">&lt;=</span> <span class="n">phi_data</span><span class="p">)</span> <span class="o">&amp;</span> \
                            <span class="p">(</span><span class="n">phi_max_minor</span> <span class="o">&gt;=</span> <span class="n">phi_data</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out_major</span> <span class="o">+</span> <span class="n">out_minor</span>

        <span class="k">return</span> <span class="n">out</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SasView 3.1.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, The SasView Project.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>