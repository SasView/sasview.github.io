<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sasmodels.resolution &mdash; SasView 4.2.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '4.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="top" title="SasView 4.2.0 documentation" href="../../index.html" />
    <link rel="up" title="sasmodels" href="../sasmodels.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SasView 4.2.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../sasmodels.html" accesskey="U">sasmodels</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sasmodels.resolution</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Define the resolution functions for the data.</span>

<span class="sd">This defines classes for 1D and 2D resolution calculations.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">unittest</span>

<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">erf</span>  <span class="c1"># type: ignore</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">log10</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pi</span>  <span class="c1"># type: ignore</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>  <span class="c1"># type: ignore</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Resolution&quot;</span><span class="p">,</span> <span class="s2">&quot;Perfect1D&quot;</span><span class="p">,</span> <span class="s2">&quot;Pinhole1D&quot;</span><span class="p">,</span> <span class="s2">&quot;Slit1D&quot;</span><span class="p">,</span>
           <span class="s2">&quot;apply_resolution_matrix&quot;</span><span class="p">,</span> <span class="s2">&quot;pinhole_resolution&quot;</span><span class="p">,</span> <span class="s2">&quot;slit_resolution&quot;</span><span class="p">,</span>
           <span class="s2">&quot;pinhole_extend_q&quot;</span><span class="p">,</span> <span class="s2">&quot;slit_extend_q&quot;</span><span class="p">,</span> <span class="s2">&quot;bin_edges&quot;</span><span class="p">,</span>
           <span class="s2">&quot;interpolate&quot;</span><span class="p">,</span> <span class="s2">&quot;linear_extrapolation&quot;</span><span class="p">,</span> <span class="s2">&quot;geometric_extrapolation&quot;</span><span class="p">,</span>
          <span class="p">]</span>

<span class="n">MINIMUM_RESOLUTION</span> <span class="o">=</span> <span class="mf">1e-8</span>
<span class="n">MINIMUM_ABSOLUTE_Q</span> <span class="o">=</span> <span class="mf">0.02</span>  <span class="c1"># relative to the minimum q in the data</span>
<span class="c1"># According to (Barker &amp; Pedersen 1995 JAC), 2.5 sigma is a good limit.</span>
<span class="c1"># According to simulations with github.com:scattering/sansresolution.git</span>
<span class="c1"># it is better to use asymmetric bounds (2.5, 3.0)</span>
<span class="n">PINHOLE_N_SIGMA</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>

<div class="viewcode-block" id="Resolution"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.Resolution">[docs]</a><span class="k">class</span> <span class="nc">Resolution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class defining a 1D resolution function.</span>

<span class="sd">    *q* is the set of q values at which the data is measured.</span>

<span class="sd">    *q_calc* is the set of q values at which the theory needs to be evaluated.</span>
<span class="sd">    This may extend and interpolate the q values.</span>

<span class="sd">    *apply* is the method to call with I(q_calc) to compute the resolution</span>
<span class="sd">    smeared theory I(q).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># type: np.ndarray</span>
    <span class="n">q_calc</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># type: np.ndarray</span>
<div class="viewcode-block" id="Resolution.apply"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.Resolution.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theory</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smear *theory* by the resolution function, returning *Iq*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Subclass does not define the apply function&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Perfect1D"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.Perfect1D">[docs]</a><span class="k">class</span> <span class="nc">Perfect1D</span><span class="p">(</span><span class="n">Resolution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resolution function to use when there is no actual resolution smearing</span>
<span class="sd">    to be applied.  It has the same interface as the other resolution</span>
<span class="sd">    functions, but returns the identity function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>

<div class="viewcode-block" id="Perfect1D.apply"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.Perfect1D.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theory</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">theory</span></div></div>


<div class="viewcode-block" id="Pinhole1D"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.Pinhole1D">[docs]</a><span class="k">class</span> <span class="nc">Pinhole1D</span><span class="p">(</span><span class="n">Resolution</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Pinhole aperture with q-dependent gaussian resolution.</span>

<span class="sd">    *q* points at which the data is measured.</span>

<span class="sd">    *q_width* gaussian 1-sigma resolution at each data point.</span>

<span class="sd">    *q_calc* is the list of points to calculate, or None if this should</span>
<span class="sd">    be estimated from the *q* and *q_width*.</span>

<span class="sd">    *nsigma* is the width of the resolution function.  Should be 2.5.</span>
<span class="sd">    See :func:`pinhole_resolution` for details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="n">q_calc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="n">PINHOLE_N_SIGMA</span><span class="p">):</span>
        <span class="c1">#*min_step* is the minimum point spacing to use when computing the</span>
        <span class="c1">#underlying model.  It should be on the order of</span>
        <span class="c1">#$\tfrac{1}{10}\tfrac{2\pi}{d_\text{max}}$ to make sure that fringes</span>
        <span class="c1">#are computed with sufficient density to avoid aliasing effects.</span>

        <span class="c1"># Protect against calls with q_width=0.  The extend_q function will</span>
        <span class="c1"># not extend the q if q_width is 0, but q_width must be non-zero when</span>
        <span class="c1"># constructing the weight matrix to avoid division by zero errors.</span>
        <span class="c1"># In practice this should never be needed, since resolution should</span>
        <span class="c1"># default to Perfect1D if the pinhole geometry is not defined.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_width</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">q_width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span> <span class="o">=</span> <span class="p">(</span><span class="n">pinhole_extend_q</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="n">nsigma</span><span class="p">)</span>
                       <span class="k">if</span> <span class="n">q_calc</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">q_calc</span><span class="p">))</span>

        <span class="c1"># Protect against models which are not defined for very low q.  Limit</span>
        <span class="c1"># the smallest q value evaluated to 0.02*min.  Note that negative q</span>
        <span class="c1"># values are trimmed even for broad resolution.  Although not possible</span>
        <span class="c1"># from the geometry, they may appear since we are using a truncated</span>
        <span class="c1"># gaussian to represent resolution rather than a skew distribution.</span>
        <span class="c1">#cutoff = MINIMUM_ABSOLUTE_Q*np.min(self.q)</span>
        <span class="c1">#self.q_calc = self.q_calc[self.q_calc &gt;= cutoff]</span>

        <span class="c1"># Build weight matrix from calculated q values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_matrix</span> <span class="o">=</span> <span class="n">pinhole_resolution</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">q_width</span><span class="p">,</span> <span class="n">MINIMUM_RESOLUTION</span><span class="p">),</span>
            <span class="n">nsigma</span><span class="o">=</span><span class="n">nsigma</span><span class="p">)</span>

<div class="viewcode-block" id="Pinhole1D.apply"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.Pinhole1D.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theory</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">apply_resolution_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">theory</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Slit1D"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.Slit1D">[docs]</a><span class="k">class</span> <span class="nc">Slit1D</span><span class="p">(</span><span class="n">Resolution</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Slit aperture with resolution function.</span>

<span class="sd">    *q* points at which the data is measured.</span>

<span class="sd">    *qx_width* slit width in qx</span>

<span class="sd">    *qy_width* slit height in qy</span>

<span class="sd">    *q_calc* is the list of points to calculate, or None if this should</span>
<span class="sd">    be estimated from the *q* and *q_width*.</span>

<span class="sd">    The *weight_matrix* is computed by :func:`slit1d_resolution`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">qx_width</span><span class="p">,</span> <span class="n">qy_width</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">q_calc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># Remember what width/dqy was used even though we won&#39;t need them</span>
        <span class="c1"># after the weight matrix is constructed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qx_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qy_width</span> <span class="o">=</span> <span class="n">qx_width</span><span class="p">,</span> <span class="n">qy_width</span>

        <span class="c1"># Allow independent resolution on each point even though it is not</span>
        <span class="c1"># needed in practice.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">qx_width</span><span class="p">):</span>
            <span class="n">qx_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">qx_width</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qx_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qx_width</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">qy_width</span><span class="p">):</span>
            <span class="n">qy_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">qy_width</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qy_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">qy_width</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span> <span class="o">=</span> <span class="n">slit_extend_q</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qx_width</span><span class="p">,</span> <span class="n">qy_width</span><span class="p">)</span> \
            <span class="k">if</span> <span class="n">q_calc</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">q_calc</span><span class="p">)</span>

        <span class="c1"># Protect against models which are not defined for very low q.  Limit</span>
        <span class="c1"># the smallest q value evaluated (in absolute) to 0.02*min</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">MINIMUM_ABSOLUTE_Q</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cutoff</span><span class="p">]</span>

        <span class="c1"># Build weight matrix from calculated q values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_matrix</span> <span class="o">=</span> \
            <span class="n">slit_resolution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">qx_width</span><span class="p">,</span> <span class="n">qy_width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_calc</span><span class="p">)</span>

<div class="viewcode-block" id="Slit1D.apply"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.Slit1D.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theory</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">apply_resolution_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">theory</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="apply_resolution_matrix"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.apply_resolution_matrix">[docs]</a><span class="k">def</span> <span class="nf">apply_resolution_matrix</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">theory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the resolution weight matrix to the computed theory function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(&quot;apply shapes&quot;, theory.shape, weight_matrix.shape)</span>
    <span class="n">Iq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">theory</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">weight_matrix</span><span class="p">)</span>
    <span class="c1">#print(&quot;result shape&quot;,Iq.shape)</span>
    <span class="k">return</span> <span class="n">Iq</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>


<div class="viewcode-block" id="pinhole_resolution"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.pinhole_resolution">[docs]</a><span class="k">def</span> <span class="nf">pinhole_resolution</span><span class="p">(</span><span class="n">q_calc</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="n">PINHOLE_N_SIGMA</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the convolution matrix *W* for pinhole resolution 1-D data.</span>

<span class="sd">    Each row *W[i]* determines the normalized weight that the corresponding</span>
<span class="sd">    points *q_calc* contribute to the resolution smeared point *q[i]*.  Given</span>
<span class="sd">    *W*, the resolution smearing can be computed using *dot(W,q)*.</span>

<span class="sd">    Note that resolution is limited to $\pm 2.5 \sigma$.[1]  The true resolution</span>
<span class="sd">    function is a broadened triangle, and does not extend over the entire</span>
<span class="sd">    range $(-\infty, +\infty)$.  It is important to impose this limitation</span>
<span class="sd">    since some models fall so steeply that the weighted value in gaussian</span>
<span class="sd">    tails would otherwise dominate the integral.</span>

<span class="sd">    *q_calc* must be increasing.  *q_width* must be greater than zero.</span>

<span class="sd">    [1] Barker, J. G., and J. S. Pedersen. 1995. Instrumental Smearing Effects</span>
<span class="sd">    in Radially Symmetric Small-Angle Neutron Scattering by Numerical and</span>
<span class="sd">    Analytical Methods. Journal of Applied Crystallography 28 (2): 105--14.</span>
<span class="sd">    https://doi.org/10.1107/S0021889894010095.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The current algorithm is a midpoint rectangle rule.  In the test case,</span>
    <span class="c1"># neither trapezoid nor Simpson&#39;s rule improved the accuracy.</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">(</span><span class="n">q_calc</span><span class="p">)</span>
    <span class="c1">#edges[edges &lt; 0.0] = 0.0 # clip edges below zero</span>
    <span class="n">cdf</span> <span class="o">=</span> <span class="n">erf</span><span class="p">((</span><span class="n">edges</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="o">*</span><span class="n">q_width</span><span class="p">)[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">cdf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Limit q range to (-2.5,+3) sigma</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nsigma_low</span><span class="p">,</span> <span class="n">nsigma_high</span> <span class="o">=</span> <span class="n">nsigma</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">nsigma_low</span> <span class="o">=</span> <span class="n">nsigma_high</span> <span class="o">=</span> <span class="n">nsigma</span>
    <span class="n">qhigh</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">nsigma_high</span><span class="o">*</span><span class="n">q_width</span>
    <span class="n">qlow</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">nsigma_low</span><span class="o">*</span><span class="n">q_width</span>  <span class="c1"># linear limits</span>
    <span class="c1">##qlow = q*q/qhigh  # log limits</span>
    <span class="n">weights</span><span class="p">[</span><span class="n">q_calc</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">qlow</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">weights</span><span class="p">[</span><span class="n">q_calc</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">qhigh</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">weights</span></div>


<div class="viewcode-block" id="slit_resolution"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.slit_resolution">[docs]</a><span class="k">def</span> <span class="nf">slit_resolution</span><span class="p">(</span><span class="n">q_calc</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">n_height</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Build a weight matrix to compute *I_s(q)* from *I(q_calc)*, given</span>
<span class="sd">    $q_\perp$ = *width* and $q_\parallel$ = *height*.  *n_height* is</span>
<span class="sd">    is the number of steps to use in the integration over $q_\parallel$</span>
<span class="sd">    when both $q_\perp$ and $q_\parallel$ are non-zero.</span>

<span class="sd">    Each $q$ can have an independent width and height value even though</span>
<span class="sd">    current instruments use the same slit setting for all measured points.</span>

<span class="sd">    If slit height is large relative to width, use:</span>

<span class="sd">    .. math::</span>

<span class="sd">        I_s(q_i) = \frac{1}{\Delta q_\perp}</span>
<span class="sd">            \int_0^{\Delta q_\perp}</span>
<span class="sd">                I\left(\sqrt{q_i^2 + q_\perp^2}\right) \,dq_\perp</span>

<span class="sd">    If slit width is large relative to height, use:</span>

<span class="sd">    .. math::</span>

<span class="sd">        I_s(q_i) = \frac{1}{2 \Delta q_\parallel}</span>
<span class="sd">            \int_{-\Delta q_\parallel}^{\Delta q_\parallel}</span>
<span class="sd">                I\left(|q_i + q_\parallel|\right) \,dq_\parallel</span>

<span class="sd">    For a mixture of slit width and height use:</span>

<span class="sd">    .. math::</span>

<span class="sd">        I_s(q_i) = \frac{1}{2 \Delta q_\parallel \Delta q_\perp}</span>
<span class="sd">            \int_{-\Delta q_\parallel}^{\Delta q_\parallel}</span>
<span class="sd">            \int_0^{\Delta q_\perp}</span>
<span class="sd">                I\left(\sqrt{(q_i + q_\parallel)^2 + q_\perp^2}\right)</span>
<span class="sd">                \,dq_\perp dq_\parallel</span>

<span class="sd">    **Definition**</span>

<span class="sd">    We are using the mid-point integration rule to assign weights to each</span>
<span class="sd">    element of a weight matrix $W$ so that</span>

<span class="sd">    .. math::</span>

<span class="sd">        I_s(q) = W\,I(q_\text{calc})</span>

<span class="sd">    If *q_calc* is at the mid-point, we can infer the bin edges from the</span>
<span class="sd">    pairwise averages of *q_calc*, adding the missing edges before</span>
<span class="sd">    *q_calc[0]* and after *q_calc[-1]*.</span>

<span class="sd">    For $q_\parallel = 0$, the smeared value can be computed numerically</span>
<span class="sd">    using the $u$ substitution</span>

<span class="sd">    .. math::</span>

<span class="sd">        u_j = \sqrt{q_j^2 - q^2}</span>

<span class="sd">    This gives</span>

<span class="sd">    .. math::</span>

<span class="sd">        I_s(q) \approx \sum_j I(u_j) \Delta u_j</span>

<span class="sd">    where $I(u_j)$ is the value at the mid-point, and $\Delta u_j$ is the</span>
<span class="sd">    difference between consecutive edges which have been first converted</span>
<span class="sd">    to $u$.  Only $u_j \in [0, \Delta q_\perp]$ are used, which corresponds</span>
<span class="sd">    to $q_j \in \left[q, \sqrt{q^2 + \Delta q_\perp}\right]$, so</span>

<span class="sd">    .. math::</span>

<span class="sd">        W_{ij} = \frac{1}{\Delta q_\perp} \Delta u_j</span>
<span class="sd">               = \frac{1}{\Delta q_\perp} \left(</span>
<span class="sd">                    \sqrt{q_{j+1}^2 - q_i^2} - \sqrt{q_j^2 - q_i^2} \right)</span>
<span class="sd">            \ \text{if}\  q_j \in \left[q_i, \sqrt{q_i^2 + q_\perp^2}\right]</span>

<span class="sd">    where $I_s(q_i)$ is the theory function being computed and $q_j$ are the</span>
<span class="sd">    mid-points between the calculated values in *q_calc*.  We tweak the</span>
<span class="sd">    edges of the initial and final intervals so that they lie on integration</span>
<span class="sd">    limits.</span>

<span class="sd">    (To be precise, the transformed midpoint $u(q_j)$ is not necessarily the</span>
<span class="sd">    midpoint of the edges $u((q_{j-1}+q_j)/2)$ and $u((q_j + q_{j+1})/2)$,</span>
<span class="sd">    but it is at least in the interval, so the approximation is going to be</span>
<span class="sd">    a little better than the left or right Riemann sum, and should be</span>
<span class="sd">    good enough for our purposes.)</span>

<span class="sd">    For $q_\perp = 0$, the $u$ substitution is simpler:</span>

<span class="sd">    .. math::</span>

<span class="sd">        u_j = \left|q_j - q\right|</span>

<span class="sd">    so</span>

<span class="sd">    .. math::</span>

<span class="sd">        W_{ij} = \frac{1}{2 \Delta q_\parallel} \Delta u_j</span>
<span class="sd">            = \frac{1}{2 \Delta q_\parallel} (q_{j+1} - q_j)</span>
<span class="sd">            \ \text{if}\ q_j \in</span>
<span class="sd">                \left[q-\Delta q_\parallel, q+\Delta q_\parallel\right]</span>

<span class="sd">    However, we need to support cases were $u_j &lt; 0$, which means using</span>
<span class="sd">    $2 (q_{j+1} - q_j)$ when $q_j \in \left[0, q_\parallel-q_i\right]$.</span>
<span class="sd">    This is not an issue for $q_i &gt; q_\parallel$.</span>

<span class="sd">    For both $q_\perp &gt; 0$ and $q_\parallel &gt; 0$ we perform a 2 dimensional</span>
<span class="sd">    integration with</span>

<span class="sd">    .. math::</span>

<span class="sd">        u_{jk} = \sqrt{q_j^2 - (q + (k\Delta q_\parallel/L))^2}</span>
<span class="sd">            \ \text{for}\ k = -L \ldots L</span>

<span class="sd">    for $L$ = *n_height*.  This gives</span>

<span class="sd">    .. math::</span>

<span class="sd">        W_{ij} = \frac{1}{2 \Delta q_\perp q_\parallel}</span>
<span class="sd">            \sum_{k=-L}^L \Delta u_{jk}</span>
<span class="sd">                \left(\frac{\Delta q_\parallel}{2 L + 1}\right)</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#np.set_printoptions(precision=6, linewidth=10000)</span>

    <span class="c1"># The current algorithm is a midpoint rectangle rule.</span>
    <span class="n">q_edges</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">(</span><span class="n">q_calc</span><span class="p">)</span> <span class="c1"># Note: requires q &gt; 0</span>
    <span class="c1">#q_edges[q_edges &lt; 0.0] = 0.0 # clip edges below zero</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">q_calc</span><span class="p">)),</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>

    <span class="c1">#print(q_calc)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">qi</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mf">0.</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="c1"># Perfect resolution, so return the theory value directly.</span>
            <span class="c1"># Note: assumes that q is a subset of q_calc.  If qi need not be</span>
            <span class="c1"># in q_calc, then we can do a weighted interpolation by looking</span>
            <span class="c1"># up qi in q_calc, then weighting the result by the relative</span>
            <span class="c1"># distance to the neighbouring points.</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_calc</span> <span class="o">==</span> <span class="n">qi</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_q_perp_weights</span><span class="p">(</span><span class="n">q_edges</span><span class="p">,</span> <span class="n">qi</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">in_x</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">((</span><span class="n">q_calc</span> <span class="o">&gt;=</span> <span class="n">qi</span><span class="o">-</span><span class="n">h</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">q_calc</span> <span class="o">&lt;=</span> <span class="n">qi</span><span class="o">+</span><span class="n">h</span><span class="p">))</span>
            <span class="n">abs_x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="p">(</span><span class="n">q_calc</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">qi</span> <span class="o">-</span> <span class="n">h</span><span class="p">))</span> <span class="k">if</span> <span class="n">qi</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="k">else</span> <span class="mf">0.</span>
            <span class="c1">#print(qi - h, qi + h)</span>
            <span class="c1">#print(in_x + abs_x)</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_x</span> <span class="o">+</span> <span class="n">abs_x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">q_edges</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_height</span><span class="p">,</span> <span class="n">n_height</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">_q_perp_weights</span><span class="p">(</span><span class="n">q_edges</span><span class="p">,</span> <span class="n">qi</span><span class="o">+</span><span class="n">k</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="n">n_height</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n_height</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">weights</span><span class="o">.</span><span class="n">T</span></div>


<span class="k">def</span> <span class="nf">_q_perp_weights</span><span class="p">(</span><span class="n">q_edges</span><span class="p">,</span> <span class="n">qi</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="c1"># Convert bin edges from q to u</span>
    <span class="n">u_limit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">u_edges</span> <span class="o">=</span> <span class="n">q_edges</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">qi</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">u_edges</span><span class="p">[</span><span class="n">q_edges</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">qi</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">u_edges</span><span class="p">[</span><span class="n">q_edges</span> <span class="o">&gt;</span> <span class="n">u_limit</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_limit</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">qi</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">u_edges</span><span class="p">))</span><span class="o">/</span><span class="n">w</span>
    <span class="c1">#print(&quot;i, qi&quot;,i,qi,qi+width)</span>
    <span class="c1">#print(q_calc)</span>
    <span class="c1">#print(weights)</span>
    <span class="k">return</span> <span class="n">weights</span>


<div class="viewcode-block" id="pinhole_extend_q"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.pinhole_extend_q">[docs]</a><span class="k">def</span> <span class="nf">pinhole_extend_q</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="n">PINHOLE_N_SIGMA</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given *q* and *q_width*, find a set of sampling points *q_calc* so</span>
<span class="sd">    that each point $I(q)$ has sufficient support from the underlying</span>
<span class="sd">    function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nsigma_low</span><span class="p">,</span> <span class="n">nsigma_high</span> <span class="o">=</span> <span class="n">nsigma</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">nsigma_low</span> <span class="o">=</span> <span class="n">nsigma_high</span> <span class="o">=</span> <span class="n">nsigma</span>
    <span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">nsigma_low</span><span class="o">*</span><span class="n">q_width</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span> <span class="o">+</span> <span class="n">nsigma_high</span><span class="o">*</span><span class="n">q_width</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">linear_extrapolation</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span><span class="p">)</span></div>


<div class="viewcode-block" id="slit_extend_q"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.slit_extend_q">[docs]</a><span class="k">def</span> <span class="nf">slit_extend_q</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given *q*, *width* and *height*, find a set of sampling points *q_calc* so</span>
<span class="sd">    that each point I(q) has sufficient support from the underlying</span>
<span class="sd">    function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="n">height</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">q</span><span class="o">+</span><span class="n">height</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">width</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">geometric_extrapolation</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span><span class="p">)</span></div>


<div class="viewcode-block" id="bin_edges"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.bin_edges">[docs]</a><span class="k">def</span> <span class="nf">bin_edges</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine bin edges from bin centers, assuming that edges are centered</span>
<span class="sd">    between the bins.</span>

<span class="sd">    Note: this uses the arithmetic mean, which may not be appropriate for</span>
<span class="sd">    log-scaled data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected bins to be an increasing set&quot;</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="c1"># first point minus half first interval</span>
        <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>        <span class="c1"># mid points of all central intervals</span>
        <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="c1"># last point plus half last interval</span>
        <span class="p">])</span>
    <span class="k">return</span> <span class="n">edges</span></div>


<div class="viewcode-block" id="interpolate"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.interpolate">[docs]</a><span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">max_step</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns *q_calc* with points spaced at most max_step apart.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="n">max_step</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="n">inserts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">q_i</span><span class="p">,</span> <span class="n">step_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">q</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">],</span> <span class="n">step</span><span class="p">[</span><span class="n">index</span><span class="p">]):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">step_i</span><span class="o">/</span><span class="n">max_step</span><span class="p">)</span>
            <span class="n">inserts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">q_i</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">step_i</span><span class="o">/</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># Extend a couple of fringes beyond the end of the data</span>
        <span class="n">inserts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="n">max_step</span><span class="p">)</span>
        <span class="n">q_calc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">inserts</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q_calc</span> <span class="o">=</span> <span class="n">q</span>
    <span class="k">return</span> <span class="n">q_calc</span></div>


<div class="viewcode-block" id="linear_extrapolation"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.linear_extrapolation">[docs]</a><span class="k">def</span> <span class="nf">linear_extrapolation</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extrapolate *q* out to [*q_min*, *q_max*] using the step size in *q* as</span>
<span class="sd">    a guide.  Extrapolation below uses about the same size as the first</span>
<span class="sd">    interval.  Extrapolation above uses about the same size as the final</span>
<span class="sd">    interval.</span>

<span class="sd">    Note that extrapolated values may be negative.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q_min</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">MINIMUM_RESOLUTION</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">n_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">q_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">15</span>
        <span class="n">q_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">q_min</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_low</span><span class="o">+</span><span class="mi">1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q_low</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">q_max</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">MINIMUM_RESOLUTION</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">n_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">q_max</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span> <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">else</span> <span class="mi">15</span>
        <span class="n">q_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">q_max</span><span class="p">,</span> <span class="n">n_high</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q_high</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">q_low</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q_high</span><span class="p">])</span></div>


<div class="viewcode-block" id="geometric_extrapolation"><a class="viewcode-back" href="../../dev/sasmodels-api/sasmodels.html#sasmodels.resolution.geometric_extrapolation">[docs]</a><span class="k">def</span> <span class="nf">geometric_extrapolation</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_min</span><span class="p">,</span> <span class="n">q_max</span><span class="p">,</span> <span class="n">points_per_decade</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Extrapolate *q* to [*q_min*, *q_max*] using geometric steps, with the</span>
<span class="sd">    average geometric step size in *q* as the step size.</span>

<span class="sd">    if *q_min* is zero or less then *q[0]/10* is used instead.</span>

<span class="sd">    *points_per_decade* sets the ratio between consecutive steps such</span>
<span class="sd">    that there will be $n$ points used for every factor of 10 increase</span>
<span class="sd">    in *q*.</span>

<span class="sd">    If *points_per_decade* is not given, it will be estimated as follows.</span>
<span class="sd">    Starting at $q_1$ and stepping geometrically by $\Delta q$ to $q_n$</span>
<span class="sd">    in $n$ points gives a geometric average of:</span>

<span class="sd">    .. math::</span>

<span class="sd">         \log \Delta q = (\log q_n - \log q_1) / (n - 1)</span>

<span class="sd">    From this we can compute the number of steps required to extend $q$</span>
<span class="sd">    from $q_n$ to $q_\text{max}$ by $\Delta q$ as:</span>

<span class="sd">    .. math::</span>

<span class="sd">         n_\text{extend} = (\log q_\text{max} - \log q_n) / \log \Delta q</span>

<span class="sd">    Substituting:</span>

<span class="sd">    .. math::</span>

<span class="sd">         n_\text{extend} = (n-1) (\log q_\text{max} - \log q_n)</span>
<span class="sd">            / (\log q_n - \log q_1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">points_per_decade</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">log_delta_q</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log_delta_q</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span> <span class="o">/</span> <span class="n">points_per_decade</span>
    <span class="k">if</span> <span class="n">q_min</span> <span class="o">&lt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">q_min</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">q_min</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">MINIMUM_ABSOLUTE_Q</span>
        <span class="n">n_low</span> <span class="o">=</span> <span class="n">log_delta_q</span> <span class="o">*</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">q_min</span><span class="p">))</span>
        <span class="n">q_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">q_min</span><span class="p">),</span> <span class="n">log10</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_low</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q_low</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">q_max</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">n_high</span> <span class="o">=</span> <span class="n">log_delta_q</span> <span class="o">*</span> <span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">q_max</span><span class="p">)</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">q_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">log10</span><span class="p">(</span><span class="n">q_max</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_high</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q_high</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">q_low</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">q_high</span><span class="p">])</span></div>


<span class="c1">############################################################################</span>
<span class="c1"># unit tests</span>
<span class="c1">############################################################################</span>

<span class="k">def</span> <span class="nf">eval_form</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the SAS model evaluated at *q*.</span>

<span class="sd">    *form* is the SAS model returned from :fun:`core.load_model`.</span>

<span class="sd">    *pars* are the parameter values to use when evaluating.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sasmodels</span> <span class="kn">import</span> <span class="n">direct_model</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">form</span><span class="o">.</span><span class="n">make_kernel</span><span class="p">([</span><span class="n">q</span><span class="p">])</span>
    <span class="n">theory</span> <span class="o">=</span> <span class="n">direct_model</span><span class="o">.</span><span class="n">call_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
    <span class="n">kernel</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">theory</span>


<span class="k">def</span> <span class="nf">gaussian</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">dq</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the truncated Gaussian resolution function.</span>

<span class="sd">    *q0* is the center, *dq* is the width and *q* are the points to evaluate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the density of the tails; the resulting gaussian needs to be</span>
    <span class="c1"># scaled by this amount in ordere to integrate to 1.0</span>
    <span class="n">two_tail_density</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">erf</span><span class="p">(</span><span class="o">-</span><span class="n">nsigma</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="o">-</span><span class="n">q0</span><span class="p">)</span><span class="o">/</span><span class="n">dq</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">dq</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">two_tail_density</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">romberg_slit_1d</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Romberg integration for slit resolution.</span>

<span class="sd">    This is an adaptive integration technique.  It is called with settings</span>
<span class="sd">    that make it slow to evaluate but give it good accuracy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">romberg</span>  <span class="c1"># type: ignore</span>

    <span class="n">par_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">form</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">call_parameters</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">par_set</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pars</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="n">par_set</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad parameters: [</span><span class="si">%s</span><span class="s2">] not in [</span><span class="si">%s</span><span class="s2">]&quot;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">extra</span><span class="p">)),</span>
                            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">pars</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
        <span class="n">height</span> <span class="o">=</span> <span class="p">[</span><span class="n">height</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">_int_w</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">,</span> <span class="n">qi</span><span class="p">:</span> <span class="n">eval_form</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">form</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
    <span class="n">_int_h</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">h</span><span class="p">,</span> <span class="n">qi</span><span class="p">:</span> <span class="n">eval_form</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">qi</span><span class="o">+</span><span class="n">h</span><span class="p">),</span> <span class="n">form</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
    <span class="c1"># If both width and height are defined, then it is too slow to use dblquad.</span>
    <span class="c1"># Instead use trapz on a fixed grid, interpolated into the I(Q) for</span>
    <span class="c1"># the extended Q range.</span>
    <span class="c1">#_int_wh = lambda w, h, qi: eval_form(sqrt((qi+h)**2 + w**2), form, pars)</span>
    <span class="n">q_calc</span> <span class="o">=</span> <span class="n">slit_extend_q</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">height</span><span class="p">))</span>
    <span class="n">Iq</span> <span class="o">=</span> <span class="n">eval_form</span><span class="p">(</span><span class="n">q_calc</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">qi</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">romberg</span><span class="p">(</span><span class="n">_int_w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">qi</span><span class="p">,),</span>
                            <span class="n">divmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">vec_func</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span><span class="o">/</span><span class="n">w</span>
        <span class="k">elif</span> <span class="n">w</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">romberg</span><span class="p">(</span><span class="n">_int_h</span><span class="p">,</span> <span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">qi</span><span class="p">,),</span>
                            <span class="n">divmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">vec_func</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">21</span><span class="p">)[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">h_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">23</span><span class="p">)[:,</span> <span class="bp">None</span><span class="p">]</span>
            <span class="n">u_sub</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">qi</span><span class="o">+</span><span class="n">h_grid</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">w_grid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">f_at_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">u_sub</span><span class="p">,</span> <span class="n">q_calc</span><span class="p">,</span> <span class="n">Iq</span><span class="p">)</span>
            <span class="c1">#print(np.trapz(Iu, w_grid, axis=1))</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">f_at_u</span><span class="p">,</span> <span class="n">w_grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">h_grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
            <span class="c1"># from scipy.integrate import dblquad</span>
            <span class="c1"># r, err = dblquad(_int_wh, -h, h, lambda h: 0., lambda h: w,</span>
            <span class="c1">#                  args=(qi,))</span>
            <span class="c1"># result[i] = r/(w*2*h)</span>

    <span class="c1"># r should be [float, ...], but it is [array([float]), array([float]),...]</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">romberg_pinhole_1d</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Romberg integration for pinhole resolution.</span>

<span class="sd">    This is an adaptive integration technique.  It is called with settings</span>
<span class="sd">    that make it slow to evaluate but give it good accuracy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">romberg</span>  <span class="c1"># type: ignore</span>

    <span class="n">par_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">form</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">call_parameters</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">par_set</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pars</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="n">par_set</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad parameters: [</span><span class="si">%s</span><span class="s2">] not in [</span><span class="si">%s</span><span class="s2">]&quot;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">extra</span><span class="p">)),</span>
                            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">pars</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span>

    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">q</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">dq</span><span class="p">:</span> <span class="n">eval_form</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span><span class="o">*</span><span class="n">gaussian</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">dq</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="p">[</span><span class="n">romberg</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">qi</span><span class="o">-</span><span class="n">nsigma</span><span class="o">*</span><span class="n">dqi</span><span class="p">,</span> <span class="mf">1e-10</span><span class="o">*</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">qi</span><span class="o">+</span><span class="n">nsigma</span><span class="o">*</span><span class="n">dqi</span><span class="p">,</span>
                     <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">qi</span><span class="p">,</span> <span class="n">dqi</span><span class="p">),</span> <span class="n">divmax</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">vec_func</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                     <span class="n">tol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">qi</span><span class="p">,</span> <span class="n">dqi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">total</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">ResolutionTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test the resolution calculations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.001</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Iq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Iq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="s2">&quot;Linear function for resolution unit test&quot;</span>
        <span class="k">return</span> <span class="mf">12.0</span> <span class="o">-</span> <span class="mf">1000.0</span><span class="o">*</span><span class="n">q</span>

    <span class="k">def</span> <span class="nf">test_perfect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perfect resolution and no smearing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Perfect1D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">theory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Iq</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_slit_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slit smearing with perfect resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Slit1D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">qx_width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">qy_width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">q_calc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">theory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Iq</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s2">&quot;not yet supported&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_slit_high</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slit smearing with height 0.005</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Slit1D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">qx_width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">qy_width</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">q_calc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">theory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Iq</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mf">9.0618</span><span class="p">,</span> <span class="mf">8.6402</span><span class="p">,</span> <span class="mf">8.1187</span><span class="p">,</span> <span class="mf">7.1392</span><span class="p">,</span> <span class="mf">6.1528</span><span class="p">,</span>
            <span class="mf">5.5555</span><span class="p">,</span> <span class="mf">4.5584</span><span class="p">,</span> <span class="mf">3.5606</span><span class="p">,</span> <span class="mf">2.5623</span><span class="p">,</span> <span class="mf">2.0000</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s2">&quot;not yet supported&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_slit_both_high</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slit smearing with width &lt; 100*height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Slit1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qx_width</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">qy_width</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">theory</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Iq</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mf">8.85785</span><span class="p">,</span> <span class="mf">8.43012</span><span class="p">,</span> <span class="mf">7.92687</span><span class="p">,</span> <span class="mf">6.94566</span><span class="p">,</span> <span class="mf">6.03660</span><span class="p">,</span>
            <span class="mf">5.40363</span><span class="p">,</span> <span class="mf">4.40655</span><span class="p">,</span> <span class="mf">3.40880</span><span class="p">,</span> <span class="mf">2.41058</span><span class="p">,</span> <span class="mf">2.00000</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s2">&quot;not yet supported&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_slit_wide</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slit smearing with width 0.0002</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Slit1D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">qx_width</span><span class="o">=</span><span class="mf">0.0002</span><span class="p">,</span> <span class="n">qy_width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">q_calc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">theory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Iq</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mf">11.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s2">&quot;not yet supported&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_slit_both_wide</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slit smearing with width &gt; 100*height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Slit1D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">qx_width</span><span class="o">=</span><span class="mf">0.0002</span><span class="p">,</span> <span class="n">qy_width</span><span class="o">=</span><span class="mf">0.000001</span><span class="p">,</span>
                            <span class="n">q_calc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">theory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Iq</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mf">11.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_pinhole_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pinhole smearing with perfect resolution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Pinhole1D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">theory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Iq</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_equal</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="c1"># TODO: turn pinhole/slit demos into tests</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s2">&quot;suppress comparison with old version; pinhole calc changed&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_pinhole</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pinhole smearing with dQ = 0.001 [Note: not dQ/Q = 0.001]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Pinhole1D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.001</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                               <span class="n">q_calc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">theory</span> <span class="o">=</span> <span class="mf">12.0</span><span class="o">-</span><span class="mf">1000.0</span><span class="o">*</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>
        <span class="c1"># Note: answer came from output of previous run.  Non-integer</span>
        <span class="c1"># values at ends come from the fact that q_calc does not</span>
        <span class="c1"># extend beyond q, and so the weights don&#39;t balance.</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mf">10.47037734</span><span class="p">,</span> <span class="mf">9.86925860</span><span class="p">,</span>
            <span class="mf">9.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span>
            <span class="mf">3.13074140</span><span class="p">,</span> <span class="mf">2.52962266</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IgorComparisonTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test resolution calculations against those returned by Igor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pars</span> <span class="o">=</span> <span class="n">TEST_PARS_PINHOLE_SPHERE</span>
        <span class="kn">from</span> <span class="nn">sasmodels</span> <span class="kn">import</span> <span class="n">core</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="s2">&quot;sphere&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eval_sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">resolution</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sasmodels</span> <span class="kn">import</span> <span class="n">direct_model</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">make_kernel</span><span class="p">([</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">])</span>
        <span class="n">theory</span> <span class="o">=</span> <span class="n">direct_model</span><span class="o">.</span><span class="n">call_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>
        <span class="n">kernel</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="c1">#err = (output - answer)/answer</span>
        <span class="c1">#idx = abs(err) &gt;= tolerance</span>
        <span class="c1">#problem = zip(q[idx], output[idx], answer[idx], err[idx])</span>
        <span class="c1">#print(&quot;\n&quot;.join(str(v) for v in problem))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_perfect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare sphere model with NIST Igor SANS, no resolution smearing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="n">TEST_PARS_SLIT_SPHERE</span>
        <span class="n">data_string</span> <span class="o">=</span> <span class="n">TEST_DATA_SLIT_SPHERE</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">data_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Perfect1D</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_sphere</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s2">&quot;suppress comparison with old version; pinhole calc changed&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_pinhole</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare pinhole resolution smearing with NIST Igor SANS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="n">TEST_PARS_PINHOLE_SPHERE</span>
        <span class="n">data_string</span> <span class="o">=</span> <span class="n">TEST_DATA_PINHOLE_SPHERE</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">data_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Pinhole1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_sphere</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="c1"># TODO: relative error should be lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mf">3e-4</span><span class="p">)</span>

    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s2">&quot;suppress comparison with old version; pinhole calc changed&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_pinhole_romberg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare pinhole resolution smearing with romberg integration result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="n">TEST_PARS_PINHOLE_SPHERE</span>
        <span class="n">data_string</span> <span class="o">=</span> <span class="n">TEST_DATA_PINHOLE_SPHERE</span>
        <span class="n">pars</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">5</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">data_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="n">romberg_pinhole_1d</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
        <span class="c1">## Getting 0.1% requires 5 sigma and 200 points per fringe</span>
        <span class="c1">#q_calc = interpolate(pinhole_extend_q(q, q_width, nsigma=5),</span>
        <span class="c1">#                     2*np.pi/pars[&#39;radius&#39;]/200)</span>
        <span class="c1">#tol = 0.001</span>
        <span class="c1">## The default 2.5 sigma and no extra points gets 1%</span>
        <span class="n">q_calc</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># type: np.ndarray</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.01</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Pinhole1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="n">q_calc</span><span class="o">=</span><span class="n">q_calc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_sphere</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># debug plot</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>  <span class="c1"># type: ignore</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">Perfect1D</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_sphere</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_slit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare slit resolution smearing with NIST Igor SANS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="n">TEST_PARS_SLIT_SPHERE</span>
        <span class="n">data_string</span> <span class="o">=</span> <span class="n">TEST_DATA_SLIT_SPHERE</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">data_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">delta_qv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Slit1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qx_width</span><span class="o">=</span><span class="n">delta_qv</span><span class="p">,</span> <span class="n">qy_width</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_sphere</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="c1"># TODO: eliminate Igor test since it is too inaccurate to be useful.</span>
        <span class="c1"># This means we can eliminate the test data as well, and instead</span>
        <span class="c1"># use a generated q vector.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_slit_romberg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare slit resolution smearing with romberg integration result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="n">TEST_PARS_SLIT_SPHERE</span>
        <span class="n">data_string</span> <span class="o">=</span> <span class="n">TEST_DATA_SLIT_SPHERE</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">data_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">delta_qv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="n">romberg_slit_1d</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">delta_qv</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
        <span class="n">q_calc</span> <span class="o">=</span> <span class="n">slit_extend_q</span><span class="p">(</span><span class="n">interpolate</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">pars</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">20</span><span class="p">),</span>
                               <span class="n">delta_qv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Slit1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qx_width</span><span class="o">=</span><span class="n">delta_qv</span><span class="p">,</span> <span class="n">qy_width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">q_calc</span><span class="o">=</span><span class="n">q_calc</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_sphere</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="c1"># TODO: relative error should be lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_ellipsoid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare romberg integration for ellipsoid model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="n">load_model</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;scale&#39;</span><span class="p">:</span><span class="mf">0.05</span><span class="p">,</span>
            <span class="s1">&#39;radius_polar&#39;</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span> <span class="s1">&#39;radius_equatorial&#39;</span><span class="p">:</span><span class="mi">15000</span><span class="p">,</span>
            <span class="s1">&#39;sld&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;sld_solvent&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="n">form</span> <span class="o">=</span> <span class="n">load_model</span><span class="p">(</span><span class="s1">&#39;ellipsoid&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;double&#39;</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="mf">4e-5</span><span class="p">),</span> <span class="n">log10</span><span class="p">(</span><span class="mf">2.5e-2</span><span class="p">),</span> <span class="mi">68</span><span class="p">)</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mf">0.117</span><span class="p">,</span> <span class="mf">0.</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Slit1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qx_width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">qy_width</span><span class="o">=</span><span class="n">height</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="n">romberg_slit_1d</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">eval_form</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pars</span><span class="p">))</span>
        <span class="c1"># TODO: 10% is too much error; use better algorithm</span>
        <span class="c1">#print(np.max(abs(answer-output)/answer))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

    <span class="c1">#TODO: can sas q spacing be too sparse for the resolution calculation?</span>
    <span class="nd">@unittest.skip</span><span class="p">(</span><span class="s2">&quot;suppress sparse data test; not supported by current code&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test_pinhole_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare pinhole resolution smearing with NIST Igor SANS on sparse data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="n">TEST_PARS_PINHOLE_SPHERE</span>
        <span class="n">data_string</span> <span class="o">=</span> <span class="n">TEST_DATA_PINHOLE_SPHERE</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">data_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">,</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">::</span><span class="mi">20</span><span class="p">]</span> <span class="c1"># Take every nth point</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">Pinhole1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_sphere</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">)</span>


<span class="c1"># pinhole sphere parameters</span>
<span class="n">TEST_PARS_PINHOLE_SPHERE</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;background&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="s1">&#39;radius&#39;</span><span class="p">:</span> <span class="mf">60.0</span><span class="p">,</span> <span class="s1">&#39;sld&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;sld_solvent&#39;</span><span class="p">:</span> <span class="mf">6.3</span><span class="p">,</span>
    <span class="p">}</span>
<span class="c1"># Q, dQ, I(Q) calculated by NIST Igor SANS package</span>
<span class="n">TEST_DATA_PINHOLE_SPHERE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">0.001278 0.0002847 2538.41176383</span>
<span class="s2">0.001562 0.0002905 2536.91820405</span>
<span class="s2">0.001846 0.0002956 2535.13182479</span>
<span class="s2">0.002130 0.0003017 2533.06217813</span>
<span class="s2">0.002414 0.0003087 2530.70378586</span>
<span class="s2">0.002698 0.0003165 2528.05024192</span>
<span class="s2">0.002982 0.0003249 2525.10408349</span>
<span class="s2">0.003266 0.0003340 2521.86667499</span>
<span class="s2">0.003550 0.0003437 2518.33907750</span>
<span class="s2">0.003834 0.0003539 2514.52246995</span>
<span class="s2">0.004118 0.0003646 2510.41798319</span>
<span class="s2">0.004402 0.0003757 2506.02690988</span>
<span class="s2">0.004686 0.0003872 2501.35067884</span>
<span class="s2">0.004970 0.0003990 2496.38678318</span>
<span class="s2">0.005253 0.0004112 2491.16237596</span>
<span class="s2">0.005537 0.0004237 2485.63911673</span>
<span class="s2">0.005821 0.0004365 2479.83657083</span>
<span class="s2">0.006105 0.0004495 2473.75676948</span>
<span class="s2">0.006389 0.0004628 2467.40145990</span>
<span class="s2">0.006673 0.0004762 2460.77293372</span>
<span class="s2">0.006957 0.0004899 2453.86724627</span>
<span class="s2">0.007241 0.0005037 2446.69623838</span>
<span class="s2">0.007525 0.0005177 2439.25775219</span>
<span class="s2">0.007809 0.0005318 2431.55421398</span>
<span class="s2">0.008093 0.0005461 2423.58785521</span>
<span class="s2">0.008377 0.0005605 2415.36158137</span>
<span class="s2">0.008661 0.0005750 2406.87009473</span>
<span class="s2">0.008945 0.0005896 2398.12841186</span>
<span class="s2">0.009229 0.0006044 2389.13360806</span>
<span class="s2">0.009513 0.0006192 2379.88958042</span>
<span class="s2">0.009797 0.0006341 2370.39776774</span>
<span class="s2">0.010080 0.0006491 2360.69528793</span>
<span class="s2">0.010360 0.0006641 2350.85169027</span>
<span class="s2">0.010650 0.0006793 2340.42023633</span>
<span class="s2">0.010930 0.0006945 2330.11206013</span>
<span class="s2">0.011220 0.0007097 2319.20109972</span>
<span class="s2">0.011500 0.0007251 2308.43503981</span>
<span class="s2">0.011780 0.0007404 2297.44820179</span>
<span class="s2">0.012070 0.0007558 2285.83853677</span>
<span class="s2">0.012350 0.0007713 2274.41290746</span>
<span class="s2">0.012640 0.0007868 2262.36219581</span>
<span class="s2">0.012920 0.0008024 2250.51169731</span>
<span class="s2">0.013200 0.0008180 2238.45596231</span>
<span class="s2">0.013490 0.0008336 2225.76495666</span>
<span class="s2">0.013770 0.0008493 2213.29618391</span>
<span class="s2">0.014060 0.0008650 2200.19110751</span>
<span class="s2">0.014340 0.0008807 2187.34050325</span>
<span class="s2">0.014620 0.0008965 2174.30529864</span>
<span class="s2">0.014910 0.0009123 2160.61632548</span>
<span class="s2">0.015190 0.0009281 2147.21038112</span>
<span class="s2">0.015470 0.0009440 2133.62023580</span>
<span class="s2">0.015760 0.0009598 2119.37907426</span>
<span class="s2">0.016040 0.0009757 2105.45234903</span>
<span class="s2">0.016330 0.0009916 2090.86319102</span>
<span class="s2">0.016610 0.0010080 2076.60576032</span>
<span class="s2">0.016890 0.0010240 2062.19214565</span>
<span class="s2">0.017180 0.0010390 2047.10550219</span>
<span class="s2">0.017460 0.0010550 2032.38715621</span>
<span class="s2">0.017740 0.0010710 2017.52560123</span>
<span class="s2">0.018030 0.0010880 2001.99124318</span>
<span class="s2">0.018310 0.0011040 1986.84662060</span>
<span class="s2">0.018600 0.0011200 1971.03389745</span>
<span class="s2">0.018880 0.0011360 1955.61395119</span>
<span class="s2">0.019160 0.0011520 1940.08291563</span>
<span class="s2">0.019450 0.0011680 1923.87672225</span>
<span class="s2">0.019730 0.0011840 1908.10656374</span>
<span class="s2">0.020020 0.0012000 1891.66297192</span>
<span class="s2">0.020300 0.0012160 1875.66789021</span>
<span class="s2">0.020580 0.0012320 1859.56357196</span>
<span class="s2">0.020870 0.0012490 1842.79468290</span>
<span class="s2">0.021150 0.0012650 1826.50064489</span>
<span class="s2">0.021430 0.0012810 1810.11533702</span>
<span class="s2">0.021720 0.0012970 1793.06840882</span>
<span class="s2">0.022000 0.0013130 1776.51153580</span>
<span class="s2">0.022280 0.0013290 1759.87201249</span>
<span class="s2">0.022570 0.0013460 1742.57354412</span>
<span class="s2">0.022850 0.0013620 1725.79397319</span>
<span class="s2">0.023140 0.0013780 1708.35831550</span>
<span class="s2">0.023420 0.0013940 1691.45256069</span>
<span class="s2">0.023700 0.0014110 1674.48561783</span>
<span class="s2">0.023990 0.0014270 1656.86525366</span>
<span class="s2">0.024270 0.0014430 1639.79847285</span>
<span class="s2">0.024550 0.0014590 1622.68887088</span>
<span class="s2">0.024840 0.0014760 1604.96421100</span>
<span class="s2">0.025120 0.0014920 1587.85768129</span>
<span class="s2">0.025410 0.0015080 1569.99297335</span>
<span class="s2">0.025690 0.0015240 1552.84580279</span>
<span class="s2">0.025970 0.0015410 1535.54074115</span>
<span class="s2">0.026260 0.0015570 1517.75249337</span>
<span class="s2">0.026540 0.0015730 1500.40115023</span>
<span class="s2">0.026820 0.0015900 1483.03632237</span>
<span class="s2">0.027110 0.0016060 1465.05942429</span>
<span class="s2">0.027390 0.0016220 1447.67682181</span>
<span class="s2">0.027670 0.0016390 1430.46495191</span>
<span class="s2">0.027960 0.0016550 1412.49232282</span>
<span class="s2">0.028240 0.0016710 1395.13182318</span>
<span class="s2">0.028520 0.0016880 1377.93439837</span>
<span class="s2">0.028810 0.0017040 1359.99528971</span>
<span class="s2">0.029090 0.0017200 1342.67274512</span>
<span class="s2">0.029370 0.0017370 1325.55375609</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># Slit sphere parameters</span>
<span class="n">TEST_PARS_SLIT_SPHERE</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;scale&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span> <span class="s1">&#39;background&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="s1">&#39;radius&#39;</span><span class="p">:</span> <span class="mi">60000</span><span class="p">,</span> <span class="s1">&#39;sld&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;sld_solvent&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">}</span>
<span class="c1"># Q dQ I(Q) I_smeared(Q)</span>
<span class="n">TEST_DATA_SLIT_SPHERE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">2.26097e-05 0.117 5.5781372896e+09 1.4626077708e+06</span>
<span class="s2">2.53847e-05 0.117 5.0363141458e+09 1.3117318023e+06</span>
<span class="s2">2.81597e-05 0.117 4.4850108103e+09 1.1594863713e+06</span>
<span class="s2">3.09347e-05 0.117 3.9364658459e+09 1.0094881630e+06</span>
<span class="s2">3.37097e-05 0.117 3.4019975074e+09 8.6518941303e+05</span>
<span class="s2">3.92597e-05 0.117 2.4139519814e+09 6.0232158311e+05</span>
<span class="s2">4.48097e-05 0.117 1.5816877820e+09 3.8739994090e+05</span>
<span class="s2">5.03597e-05 0.117 9.3715407224e+08 2.2745304775e+05</span>
<span class="s2">5.59097e-05 0.117 4.8387917428e+08 1.2101295768e+05</span>
<span class="s2">6.14597e-05 0.117 2.0193586928e+08 6.0055107771e+04</span>
<span class="s2">6.70097e-05 0.117 5.5886110911e+07 3.2749521065e+04</span>
<span class="s2">7.25597e-05 0.117 3.7782348010e+06 2.6350963616e+04</span>
<span class="s2">7.81097e-05 0.117 5.3407817904e+06 2.9624963314e+04</span>
<span class="s2">8.36597e-05 0.117 2.7975485523e+07 3.4403962254e+04</span>
<span class="s2">8.92097e-05 0.117 4.9845448282e+07 3.6130017903e+04</span>
<span class="s2">9.47597e-05 0.117 6.0092588905e+07 3.3495107849e+04</span>
<span class="s2">1.00310e-04 0.117 5.6823430831e+07 2.7475726279e+04</span>
<span class="s2">1.05860e-04 0.117 4.3857024036e+07 2.0144282226e+04</span>
<span class="s2">1.11410e-04 0.117 2.7277144760e+07 1.3647403260e+04</span>
<span class="s2">1.22510e-04 0.117 3.3119334113e+06 6.6519711526e+03</span>
<span class="s2">1.33610e-04 0.117 1.4412859402e+06 6.9726212813e+03</span>
<span class="s2">1.44710e-04 0.117 8.5620162463e+06 8.1441335775e+03</span>
<span class="s2">1.55810e-04 0.117 9.6957429033e+06 6.4559996521e+03</span>
<span class="s2">1.66910e-04 0.117 4.3818341914e+06 3.6252154156e+03</span>
<span class="s2">1.78010e-04 0.117 2.7448997387e+05 2.4006505342e+03</span>
<span class="s2">1.89110e-04 0.117 8.0472009936e+05 2.8187789089e+03</span>
<span class="s2">2.00210e-04 0.117 2.8149552834e+06 3.0915662855e+03</span>
<span class="s2">2.11310e-04 0.117 2.7510907861e+06 2.3722530293e+03</span>
<span class="s2">2.22410e-04 0.117 1.0053133293e+06 1.4473468311e+03</span>
<span class="s2">2.33510e-04 0.117 5.8428305052e+03 1.2048540556e+03</span>
<span class="s2">2.44610e-04 0.117 5.1699305004e+05 1.4625670042e+03</span>
<span class="s2">2.55710e-04 0.117 1.2120227268e+06 1.5010705973e+03</span>
<span class="s2">2.66810e-04 0.117 9.7896842846e+05 1.1336343426e+03</span>
<span class="s2">2.77910e-04 0.117 2.5507264791e+05 8.1848818080e+02</span>
<span class="s2">3.05660e-04 0.117 5.2403101181e+05 7.4913374357e+02</span>
<span class="s2">3.33410e-04 0.117 5.8699343809e+04 4.4669964560e+02</span>
<span class="s2">3.61160e-04 0.117 3.0844327150e+05 4.6774007542e+02</span>
<span class="s2">3.88910e-04 0.117 8.3360142970e+03 2.7169550220e+02</span>
<span class="s2">4.16660e-04 0.117 1.8630080583e+05 3.0710983679e+02</span>
<span class="s2">4.44410e-04 0.117 3.1616804732e-01 1.7959006831e+02</span>
<span class="s2">4.72160e-04 0.117 1.1299016314e+05 2.0763952339e+02</span>
<span class="s2">4.99910e-04 0.117 2.9952522747e+03 1.2536542765e+02</span>
<span class="s2">5.27660e-04 0.117 6.7625695649e+04 1.4013969777e+02</span>
<span class="s2">5.55410e-04 0.117 7.6927460089e+03 8.2145593180e+01</span>
<span class="s2">6.10910e-04 0.117 1.1229057779e+04 8.4519745643e+01</span>
<span class="s2">6.66410e-04 0.117 1.3035567943e+04 8.1554625609e+01</span>
<span class="s2">7.21910e-04 0.117 1.3309931343e+04 7.4437319172e+01</span>
<span class="s2">7.77410e-04 0.117 1.2462626212e+04 6.4697088261e+01</span>
<span class="s2">8.32910e-04 0.117 1.0912927143e+04 5.3773301044e+01</span>
<span class="s2">8.88410e-04 0.117 9.0172597469e+03 4.2843375753e+01</span>
<span class="s2">9.43910e-04 0.117 7.0496495917e+03 3.2771032724e+01</span>
<span class="s2">9.99410e-04 0.117 5.2030483682e+03 2.4113557144e+01</span>
<span class="s2">1.05491e-03 0.117 3.5988976711e+03 1.7160773658e+01</span>
<span class="s2">1.11041e-03 0.117 2.2996060652e+03 1.2016626459e+01</span>
<span class="s2">1.22141e-03 0.117 6.4766590598e+02 6.0373017740e+00</span>
<span class="s2">1.33241e-03 0.117 4.1963483264e+01 4.5215452974e+00</span>
<span class="s2">1.44341e-03 0.117 6.3370708246e+01 5.1054681903e+00</span>
<span class="s2">1.55441e-03 0.117 3.0736750577e+02 5.9176165298e+00</span>
<span class="s2">1.66541e-03 0.117 5.0327682399e+02 5.9815000189e+00</span>
<span class="s2">1.77641e-03 0.117 5.4084331454e+02 5.1634639625e+00</span>
<span class="s2">1.88741e-03 0.117 4.3488671756e+02 3.8535158148e+00</span>
<span class="s2">1.99841e-03 0.117 2.6322287860e+02 2.5824997753e+00</span>
<span class="s2">2.10941e-03 0.117 1.0793633150e+02 1.7315517194e+00</span>
<span class="s2">2.22041e-03 0.117 1.8474448850e+01 1.4077213604e+00</span>
<span class="s2">2.33141e-03 0.117 1.5864062279e+00 1.4771560682e+00</span>
<span class="s2">2.44241e-03 0.117 3.2267213848e+01 1.6916253448e+00</span>
<span class="s2">2.55341e-03 0.117 7.4289116207e+01 1.8274751193e+00</span>
<span class="s2">2.66441e-03 0.117 9.9000521929e+01 1.7706812289e+00</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run tests given is sys.argv.</span>

<span class="sd">    Returns 0 if success or 1 if any tests fail.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">import</span> <span class="nn">xmlrunner</span>  <span class="c1"># type: ignore</span>

    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">defaultTestLoader</span><span class="o">.</span><span class="n">loadTestsFromModule</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">__name__</span><span class="p">]))</span>

    <span class="n">runner</span> <span class="o">=</span> <span class="n">xmlrunner</span><span class="o">.</span><span class="n">XMLTestRunner</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;logs&#39;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">failures</span> <span class="ow">or</span> <span class="n">result</span><span class="o">.</span><span class="n">errors</span> <span class="k">else</span> <span class="mi">0</span>


<span class="c1">############################################################################</span>
<span class="c1"># usage demo</span>
<span class="c1">############################################################################</span>

<span class="k">def</span> <span class="nf">_eval_demo_1d</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">from</span> <span class="nn">sasmodels</span> <span class="kn">import</span> <span class="n">core</span>
    <span class="kn">from</span> <span class="nn">sasmodels</span> <span class="kn">import</span> <span class="n">direct_model</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;cylinder&#39;</span>

    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;cylinder&#39;</span><span class="p">:</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;length&#39;</span><span class="p">:</span><span class="mi">210</span><span class="p">,</span> <span class="s1">&#39;radius&#39;</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span> <span class="s1">&#39;background&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;teubner_strey&#39;</span><span class="p">:</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a2&#39;</span><span class="p">:</span><span class="mf">0.003</span><span class="p">,</span> <span class="s1">&#39;c1&#39;</span><span class="p">:</span><span class="o">-</span><span class="mf">1e4</span><span class="p">,</span> <span class="s1">&#39;c2&#39;</span><span class="p">:</span><span class="mf">1e10</span><span class="p">,</span> <span class="s1">&#39;background&#39;</span><span class="p">:</span><span class="mf">0.312643</span><span class="p">}</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;sphere&#39;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;spherepy&#39;</span><span class="p">:</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="n">TEST_PARS_SLIT_SPHERE</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;ellipsoid&#39;</span><span class="p">:</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;scale&#39;</span><span class="p">:</span><span class="mf">0.05</span><span class="p">,</span> <span class="s1">&#39;background&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;r_polar&#39;</span><span class="p">:</span><span class="mi">500</span><span class="p">,</span> <span class="s1">&#39;r_equatorial&#39;</span><span class="p">:</span><span class="mi">15000</span><span class="p">,</span>
            <span class="s1">&#39;sld&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;sld_solvent&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">model_info</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">load_model_info</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">build_model</span><span class="p">(</span><span class="n">model_info</span><span class="p">)</span>

    <span class="n">kernel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">make_kernel</span><span class="p">([</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">])</span>
    <span class="n">theory</span> <span class="o">=</span> <span class="n">direct_model</span><span class="o">.</span><span class="n">call_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
    <span class="n">Iq</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">theory</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">Slit1D</span><span class="p">):</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">qx_width</span><span class="p">,</span> <span class="n">resolution</span><span class="o">.</span><span class="n">qy_width</span>
        <span class="n">Iq_romb</span> <span class="o">=</span> <span class="n">romberg_slit_1d</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dq</span> <span class="o">=</span> <span class="n">resolution</span><span class="o">.</span><span class="n">q_width</span>
        <span class="n">Iq_romb</span> <span class="o">=</span> <span class="n">romberg_pinhole_1d</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">dq</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">pars</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>  <span class="c1"># type: ignore</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q_calc</span><span class="p">,</span> <span class="n">theory</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;unsmeared&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">Iq</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;smeared&#39;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">loglog</span><span class="p">(</span><span class="n">resolution</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">Iq_romb</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;romberg smeared&#39;</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Q (1/Ang)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;I(Q) (1/cm)&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">demo_pinhole_1d</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Show example of pinhole smearing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">0.2</span><span class="p">),</span> <span class="mi">400</span><span class="p">)</span>
    <span class="n">q_width</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">q</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="n">Pinhole1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q_width</span><span class="p">)</span>
    <span class="n">_eval_demo_1d</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;10</span><span class="si">% d</span><span class="s2">Q/Q Pinhole Resolution&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">demo_slit_1d</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Show example of slit smearing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mf">0.2</span><span class="p">),</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">h</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="c1">#w = 0.000000277790</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.0277790</span>
    <span class="c1">#h = 0.00277790</span>
    <span class="c1">#h = 0.0277790</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="n">Slit1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">_eval_demo_1d</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;(</span><span class="si">%g</span><span class="s2">,</span><span class="si">%g</span><span class="s2">) Slit Resolution&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run the resolution demos.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>  <span class="c1"># type: ignore</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
    <span class="n">demo_pinhole_1d</span><span class="p">()</span>
    <span class="c1">#plt.yscale(&#39;linear&#39;)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
    <span class="n">demo_slit_1d</span><span class="p">()</span>
    <span class="c1">#plt.yscale(&#39;linear&#39;)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1">#demo()</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SasView 4.2.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../sasmodels.html" >sasmodels</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2018, The SasView Project.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>